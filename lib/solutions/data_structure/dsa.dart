final List<Map<String, String>> dsaData = [
{
"id": "1",
"question": "What is the time complexity of searching for an element in a sorted array using binary search?",
"solution": "The time complexity of binary search is O(log n), where n is the size of the array.\n\n```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1  # Element not found\n\n# Example usage\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ntarget = 7\nresult = binary_search(arr, target)\nprint(f\"Element found at index: {result}\")\n```"
},
{
"id": "2",
"question": "How do you reverse a linked list in-place?",
"solution": "To reverse a linked list in-place, we need to change the direction of all pointers using three pointers: current, previous, and next.\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_linked_list(head):\n    prev = None\n    current = head\n    \n    while current:\n        next_temp = current.next  # Store next node\n        current.next = prev       # Reverse the pointer\n        prev = current            # Move prev forward\n        current = next_temp       # Move current forward\n    \n    return prev  # New head of the reversed list\n\n# Example usage\ndef print_linked_list(head):\n    current = head\n    values = []\n    while current:\n        values.append(str(current.val))\n        current = current.next\n    print(' -> '.join(values))\n\n# Create a linked list: 1 -> 2 -> 3 -> 4 -> 5\nhead = ListNode(1)\nhead.next = ListNode(2)\nhead.next.next = ListNode(3)\nhead.next.next.next = ListNode(4)\nhead.next.next.next.next = ListNode(5)\n\nprint(\"Original linked list:\")\nprint_linked_list(head)\n\n# Reverse the linked list\nreversed_head = reverse_linked_list(head)\n\nprint(\"Reversed linked list:\")\nprint_linked_list(reversed_head)\n```"
},
{
"id": "3",
"question": "Implement a function to find the maximum depth of a binary tree.",
"solution": "The maximum depth of a binary tree is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_depth(root):\n    if not root:\n        return 0\n    \n    # Recursively find the depth of left and right subtrees\n    left_depth = max_depth(root.left)\n    right_depth = max_depth(root.right)\n    \n    # Return the larger depth plus 1 (for the current node)\n    return max(left_depth, right_depth) + 1\n\n# Example usage\n# Create a binary tree:      3\n#                           / \\\n#                          9  20\n#                             / \\\n#                            15  7\nroot = TreeNode(3)\nroot.left = TreeNode(9)\nroot.right = TreeNode(20)\nroot.right.left = TreeNode(15)\nroot.right.right = TreeNode(7)\n\ndepth = max_depth(root)\nprint(f\"Maximum depth of the binary tree: {depth}\")\n```"
},
{
"id": "4",
"question": "Given an array of integers, find two numbers such that they add up to a specific target number.",
"solution": "We can solve this efficiently using a hash map to store values we've seen and their indices.\n\n```python\ndef two_sum(nums, target):\n    # Dictionary to store numbers we've seen and their indices\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        # If the complement exists in the dictionary, we found a solution\n        if complement in seen:\n            return [seen[complement], i]\n        \n        # Store the current number and its index\n        seen[num] = i\n    \n    return []  # No solution found\n\n# Example usage\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(f\"Indices of the two numbers: {result}\")\nprint(f\"Numbers: {nums[result[0]]} and {nums[result[1]]}\")\n```"
},
{
"id": "5",
"question": "How do you detect a cycle in a linked list?",
"solution": "We can use Floyd's Cycle-Finding Algorithm (also known as the 'tortoise and hare' algorithm) to detect a cycle in a linked list.\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef has_cycle(head):\n    if not head or not head.next:\n        return False\n    \n    # Slow pointer moves one step at a time\n    slow = head\n    # Fast pointer moves two steps at a time\n    fast = head.next\n    \n    while slow != fast:\n        # If the fast pointer reaches the end, there's no cycle\n        if not fast or not fast.next:\n            return False\n        \n        slow = slow.next         # Move slow pointer by one step\n        fast = fast.next.next    # Move fast pointer by two steps\n    \n    return True  # If slow and fast meet, there's a cycle\n\n# Example usage\n# Create a linked list with a cycle: 1 -> 2 -> 3 -> 4 -> 5 -> 3 (cycle back to node with value 3)\nhead = ListNode(1)\nhead.next = ListNode(2)\nhead.next.next = ListNode(3)\nhead.next.next.next = ListNode(4)\nhead.next.next.next.next = ListNode(5)\n\n# Create a cycle by connecting the last node to the third node\nhead.next.next.next.next.next = head.next.next  # Connect to node with value 3\n\nresult = has_cycle(head)\nprint(f\"Does the linked list have a cycle? {result}\")\n\n# Create a linked list without a cycle: 1 -> 2 -> 3 -> 4 -> 5 -> None\nhead_no_cycle = ListNode(1)\nhead_no_cycle.next = ListNode(2)\nhead_no_cycle.next.next = ListNode(3)\nhead_no_cycle.next.next.next = ListNode(4)\nhead_no_cycle.next.next.next.next = ListNode(5)\n\nresult_no_cycle = has_cycle(head_no_cycle)\nprint(f\"Does the second linked list have a cycle? {result_no_cycle}\")\n```"
},
{
"id": "6",
"question": "Implement a stack using two queues.",
"solution": "We can implement a stack using two queues by making either push or pop operation costly.\n\n```python\nfrom collections import deque\n\nclass Stack:\n    def __init__(self):\n        self.q1 = deque()  # Main queue\n        self.q2 = deque()  # Auxiliary queue\n    \n    def push(self, x):\n        # Add new element to q2\n        self.q2.append(x)\n        \n        # Move all elements from q1 to q2\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        \n        # Swap q1 and q2\n        self.q1, self.q2 = self.q2, self.q1\n    \n    def pop(self):\n        if not self.q1:\n            return None\n        return self.q1.popleft()\n    \n    def top(self):\n        if not self.q1:\n            return None\n        return self.q1[0]\n    \n    def empty(self):\n        return len(self.q1) == 0\n\n# Example usage\nstack = Stack()\nstack.push(1)\nstack.push(2)\nstack.push(3)\n\nprint(f\"Top element: {stack.top()}\")\nprint(f\"Pop: {stack.pop()}\")\nprint(f\"Pop: {stack.pop()}\")\nprint(f\"Is stack empty? {stack.empty()}\")\nprint(f\"Pop: {stack.pop()}\")\nprint(f\"Is stack empty? {stack.empty()}\")\n```"
},
{
"id": "7",
"question": "How do you find the longest substring without repeating characters?",
"solution": "We can use a sliding window approach with a hash map to keep track of the characters we've seen.\n\n```python\ndef length_of_longest_substring(s):\n    char_dict = {}  # Dictionary to store characters and their indices\n    max_length = 0\n    start = 0\n    \n    for end, char in enumerate(s):\n        # If character is already in the current window, update start pointer\n        if char in char_dict and char_dict[char] >= start:\n            start = char_dict[char] + 1\n        else:\n            # Update max_length if current window is larger\n            max_length = max(max_length, end - start + 1)\n        \n        # Update character's position in dictionary\n        char_dict[char] = end\n    \n    return max_length\n\n# Example usage\ns1 = \"abcabcbb\"\nprint(f\"Length of longest substring without repeating characters in '{s1}': {length_of_longest_substring(s1)}\")\n\ns2 = \"bbbbb\"\nprint(f\"Length of longest substring without repeating characters in '{s2}': {length_of_longest_substring(s2)}\")\n\ns3 = \"pwwkew\"\nprint(f\"Length of longest substring without repeating characters in '{s3}': {length_of_longest_substring(s3)}\")\n```"
},
{
"id": "8",
"question": "Implement a function to check if a binary tree is balanced.",
"solution": "A balanced binary tree is one where the height of the left and right subtrees of any node differ by no more than 1.\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_balanced(root):\n    # Helper function to calculate height and check balance\n    def check_height(node):\n        if not node:\n            return 0\n        \n        # Check left subtree\n        left_height = check_height(node.left)\n        if left_height == -1:\n            return -1  # Left subtree is unbalanced\n        \n        # Check right subtree\n        right_height = check_height(node.right)\n        if right_height == -1:\n            return -1  # Right subtree is unbalanced\n        \n        # Check if current node is balanced\n        if abs(left_height - right_height) > 1:\n            return -1  # Current node is unbalanced\n        \n        # Return height of current subtree\n        return max(left_height, right_height) + 1\n    \n    return check_height(root) != -1\n\n# Example usage\n# Create a balanced binary tree:    3\n#                                  / \\\n#                                 9  20\n#                                   /  \\\n#                                  15   7\nbalanced_tree = TreeNode(3)\nbalanced_tree.left = TreeNode(9)\nbalanced_tree.right = TreeNode(20)\nbalanced_tree.right.left = TreeNode(15)\nbalanced_tree.right.right = TreeNode(7)\n\nprint(f\"Is the first tree balanced? {is_balanced(balanced_tree)}\")\n\n# Create an unbalanced binary tree:  1\n#                                   / \\\n#                                  2   2\n#                                 /\n#                                3\n#                               /\n#                              4\nunbalanced_tree = TreeNode(1)\nunbalanced_tree.left = TreeNode(2)\nunbalanced_tree.right = TreeNode(2)\nunbalanced_tree.left.left = TreeNode(3)\nunbalanced_tree.left.left.left = TreeNode(4)\n\nprint(f\"Is the second tree balanced? {is_balanced(unbalanced_tree)}\")\n```"
},
{
"id": "9",
"question": "Implement a min heap data structure.",
"solution": "A min heap is a complete binary tree where the value of each node is less than or equal to the values of its children.\n\n```python\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i):\n        return (i - 1) // 2\n    \n    def left_child(self, i):\n        return 2 * i + 1\n    \n    def right_child(self, i):\n        return 2 * i + 2\n    \n    def get_min(self):\n        if not self.heap:\n            return None\n        return self.heap[0]\n    \n    def insert(self, value):\n        self.heap.append(value)\n        current = len(self.heap) - 1\n        \n        # Heapify up\n        while current > 0 and self.heap[current] < self.heap[self.parent(current)]:\n            # Swap with parent\n            self.heap[current], self.heap[self.parent(current)] = \\\n                self.heap[self.parent(current)], self.heap[current]\n            current = self.parent(current)\n    \n    def extract_min(self):\n        if not self.heap:\n            return None\n        \n        min_val = self.heap[0]\n        \n        # Replace root with last element\n        self.heap[0] = self.heap[-1]\n        self.heap.pop()\n        \n        # Heapify down\n        self._heapify_down(0)\n        \n        return min_val\n    \n    def _heapify_down(self, i):\n        smallest = i\n        left = self.left_child(i)\n        right = self.right_child(i)\n        heap_size = len(self.heap)\n        \n        # Check if left child exists and is smaller than current smallest\n        if left < heap_size and self.heap[left] < self.heap[smallest]:\n            smallest = left\n        \n        # Check if right child exists and is smaller than current smallest\n        if right < heap_size and self.heap[right] < self.heap[smallest]:\n            smallest = right\n        \n        # If smallest is not the current node, swap and continue heapifying\n        if smallest != i:\n            self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i]\n            self._heapify_down(smallest)\n\n# Example usage\nmin_heap = MinHeap()\nmin_heap.insert(5)\nmin_heap.insert(3)\nmin_heap.insert(8)\nmin_heap.insert(1)\nmin_heap.insert(10)\n\nprint(f\"Min value: {min_heap.get_min()}\")\nprint(f\"Extract min: {min_heap.extract_min()}\")\nprint(f\"New min value: {min_heap.get_min()}\")\nprint(f\"Extract min: {min_heap.extract_min()}\")\nprint(f\"Current heap: {min_heap.heap}\")\n```"
},
{
"id": "10",
"question": "Given a sorted array, create a balanced binary search tree.",
"solution": "We can use a recursive approach, taking the middle element as the root at each step.\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sorted_array_to_bst(nums):\n    if not nums:\n        return None\n    \n    # Find the middle element\n    mid = len(nums) // 2\n    \n    # Create the root node with the middle element\n    root = TreeNode(nums[mid])\n    \n    # Recursively build left and right subtrees\n    root.left = sorted_array_to_bst(nums[:mid])\n    root.right = sorted_array_to_bst(nums[mid+1:])\n    \n    return root\n\n# Example usage\ndef inorder_traversal(root):\n    if not root:\n        return []\n    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)\n\nnums = [-10, -3, 0, 5, 9]\nroot = sorted_array_to_bst(nums)\n\n# Inorder traversal should return the original sorted array\nprint(f\"Original sorted array: {nums}\")\nprint(f\"Inorder traversal of BST: {inorder_traversal(root)}\")\n```"
},
{
"id": "11",
"question": "How do you implement Breadth-First Search (BFS) on a graph?",
"solution": "BFS explores all the vertices of a graph in breadth-first order, i.e., it visits all the vertices at the same level before moving to the next level.\n\n```python\nfrom collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n    \n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n    \n    def bfs(self, start):\n        # Mark all vertices as not visited\n        visited = set()\n        \n        # Create a queue for BFS\n        queue = deque([start])\n        visited.add(start)\n        \n        result = []\n        \n        while queue:\n            # Dequeue a vertex from queue\n            vertex = queue.popleft()\n            result.append(vertex)\n            \n            # Get all adjacent vertices of the dequeued vertex\n            # If an adjacent vertex has not been visited, mark it as visited and enqueue it\n            for neighbor in self.graph[vertex]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        return result\n\n# Example usage\ng = Graph()\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\n\nprint(\"BFS traversal starting from vertex 2:\")\nprint(g.bfs(2))\n```"
},
{
"id": "12",
"question": "Implement Depth-First Search (DFS) on a graph.",
"solution": "DFS explores as far as possible along each branch before backtracking.\n\n```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n    \n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n    \n    def dfs_util(self, vertex, visited, result):\n        # Mark the current node as visited and add to result\n        visited.add(vertex)\n        result.append(vertex)\n        \n        # Recur for all the vertices adjacent to this vertex\n        for neighbor in self.graph[vertex]:\n            if neighbor not in visited:\n                self.dfs_util(neighbor, visited, result)\n    \n    def dfs(self, start):\n        # Mark all the vertices as not visited\n        visited = set()\n        result = []\n        \n        # Call the recursive helper function\n        self.dfs_util(start, visited, result)\n        \n        return result\n\n# Example usage\ng = Graph()\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\n\nprint(\"DFS traversal starting from vertex 2:\")\nprint(g.dfs(2))\n```"
},
{
"id": "13",
"question": "Implement the merge sort algorithm.",
"solution": "Merge sort is a divide-and-conquer algorithm that divides the input array into two halves, sorts them separately, and then merges them.\n\n```python\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    # Divide array into two halves\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # Recursively sort both halves\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n    \n    # Merge the sorted halves\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    # Compare elements from both arrays and add the smaller one to the result\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Add remaining elements\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# Example usage\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(f\"Original array: {arr}\")\nsorted_arr = merge_sort(arr)\nprint(f\"Sorted array: {sorted_arr}\")\n```"
},
{
"id": "14",
"question": "Implement the quicksort algorithm.",
"solution": "Quicksort is a divide-and-conquer algorithm that selects a 'pivot' element and partitions the array around it.\n\n```python\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = arr[len(arr) // 2]  # Choose middle element as pivot\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return quicksort(left) + middle + quicksort(right)\n\n# Example usage\narr = [10, 7, 8, 9, 1, 5]\nprint(f\"Original array: {arr}\")\nsorted_arr = quicksort(arr)\nprint(f\"Sorted array: {sorted_arr}\")\n\n# Alternative implementation with in-place partitioning\ndef quicksort_inplace(arr, low, high):\n    if low < high:\n        # Partition the array and get the pivot index\n        pivot_index = partition(arr, low, high)\n        \n        # Sort the elements before and after the pivot\n        quicksort_inplace(arr, low, pivot_index - 1)\n        quicksort_inplace(arr, pivot_index + 1, high)\n\ndef partition(arr, low, high):\n    # Choose the rightmost element as the pivot\n    pivot = arr[high]\n    \n    # Index of smaller element\n    i = low - 1\n    \n    for j in range(low, high):\n        # If current element is smaller than or equal to the pivot\n        if arr[j] <= pivot:\n            # Increment index of smaller element\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Place the pivot in its correct position\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    \n    return i + 1\n\n# Example usage of in-place quicksort\narr2 = [10, 7, 8, 9, 1, 5]\nprint(f\"\\nOriginal array: {arr2}\")\nquicksort_inplace(arr2, 0, len(arr2) - 1)\nprint(f\"Sorted array (in-place): {arr2}\")\n```"
},
{
"id": "15",
"question": "Implement a Trie (Prefix Tree) data structure.",
"solution": "A Trie is a tree-like data structure used to store a dynamic set of strings, where the keys are usually strings.\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n    \n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n    \n    def starts_with(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\n# Example usage\ntrie = Trie()\nwords = [\"apple\", \"app\", \"apricot\", \"banana\", \"bat\"]\n\nfor word in words:\n    trie.insert(word)\n\nprint(f\"Search 'apple': {trie.search('apple')}\")\nprint(f\"Search 'app': {trie.search('app')}\")\nprint(f\"Search 'appl': {trie.search('appl')}\")\nprint(f\"Starts with 'app': {trie.starts_with('app')}\")\nprint(f\"Starts with 'bat': {trie.starts_with('bat')}\")\nprint(f\"Starts with 'ban': {trie.starts_with('ban')}\")\n```"
},
{
"id": "16",
"question": "Implement a function to find the lowest common ancestor of two nodes in a binary tree.",
"solution": "The lowest common ancestor (LCA) is defined as the lowest node in the tree that has both nodes as descendants.\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowest_common_ancestor(root, p, q):\n    # Base case\n    if not root or root == p or root == q:\n        return root\n    \n    # Look for keys in left and right subtrees\n    left = lowest_common_ancestor(root.left, p, q)\n    right = lowest_common_ancestor(root.right, p, q)\n    \n    # If both nodes were found in different subtrees, current node is the LCA\n    if left and right:\n        return root\n    \n    # Otherwise, return the non-null value (if any)\n    return left if left else right\n\n# Example usage\n# Create a binary tree:          3\n#                               / \\\n#                              5   1\n#                             / \\ / \\\n#                            6  2 0  8\n#                              / \\\n#                             7   4\nroot = TreeNode(3)\nroot.left = TreeNode(5)\nroot.right = TreeNode(1)\nroot.left.left = TreeNode(6)\nroot.left.right = TreeNode(2)\nroot.right.left = TreeNode(0)\nroot.right.right = TreeNode(8)\nroot.left.right.left = TreeNode(7)\nroot.left.right.right = TreeNode(4)\n\n# Find LCA of nodes with values 5 and 1 (should be 3)\nlca1 = lowest_common_ancestor(root, root.left, root.right)\nprint(f\"LCA of 5 and 1: {lca1.val}\")\n\n# Find LCA of nodes with values 5 and 4 (should be 5)\nlca2 = lowest_common_ancestor(root, root.left, root.left.right.right)\nprint(f\"LCA of 5 and 4: {lca2.val}\")\n```"
},
{
"id": "17",
"question": "Implement a function to check if a binary tree is a valid Binary Search Tree (BST).",
"solution": "A valid BST is defined as follows: the left subtree of a node contains only nodes with keys less than the node's key, the right subtree of a node contains only nodes with keys greater than the node's key, and both the left and right subtrees must also be BSTs.\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    # Helper function to check if all values in the tree are within a range\n    def validate(node, low=float('-inf'), high=float('inf')):\n        # Empty trees are valid BSTs\n        if not node:\n            return True\n        \n        # Current node's value must be between low and high\n        if node.val <= low or node.val >= high:\n            return False\n        \n        # Check left and right subtrees\n        return (validate(node.left, low, node.val) and \n                validate(node.right, node.val, high))\n    \n    return validate(root)\n\n# Example usage\n# Create a valid BST:      2\n#                         / \\\n#                        1   3\nvalid_bst = TreeNode(2)\nvalid_bst.left = TreeNode(1)\nvalid_bst.right = TreeNode(3)\n\nprint(f\"Is the first tree a valid BST? {is_valid_bst(valid_bst)}\")\n\n# Create an invalid BST:   5\n#                         / \\\n#                        1   4\n#                           / \\\n#                          3   6\n# (Note: 3 is in the right subtree of 5 but is less than 5)\ninvalid_bst = TreeNode(5)\ninvalid_bst.left = TreeNode(1)\ninvalid_bst.right = TreeNode(4)\ninvalid_bst.right.left = TreeNode(3)\ninvalid_bst.right.right = TreeNode(6)\n\nprint(f\"Is the second tree a valid BST? {is_valid_bst(invalid_bst)}\")\n```"
},
{
"id": "18",
"question": "Implement the Dijkstra's algorithm for finding the shortest path in a weighted graph.",
"solution": "Dijkstra's algorithm finds the shortest path from a source vertex to all other vertices in a weighted graph with non-negative edge weights.\n\n```python\nimport heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph, start):\n    # Priority queue to store vertices and their distances\n    # Format: (distance, vertex)\n    priority_queue = [(0, start)]\n    \n    # Dictionary to store the shortest distance to each vertex\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[start] = 0\n    \n    # Dictionary to store the previous vertex in the optimal path\n    previous = {vertex: None for vertex in graph}\n    \n    while priority_queue:\n        # Get the vertex with the smallest distance\n        current_distance, current_vertex = heapq.heappop(priority_queue)\n        \n        # If we've already found a better path, skip this iteration\n        if current_distance > distances[current_vertex]:\n            continue\n        \n        # Check all neighbors of the current vertex\n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_distance + weight\n            \n            # If we found a better path to the neighbor, update it\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous[neighbor] = current_vertex\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances, previous\n\n# Helper function to reconstruct the path from start to end\ndef reconstruct_path(previous, start, end):\n    path = []\n    current = end\n    \n    while current != start:\n        path.append(current)\n        current = previous[current]\n        if current is None:\n            return []  # No path exists\n    \n    path.append(start)\n    return path[::-1]  # Reverse to get path from start to end\n\n# Example usage\n# Create a weighted graph\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\nstart_vertex = 'A'\ndistances, previous = dijkstra(graph, start_vertex)\n\nprint(f\"Shortest distances from {start_vertex}:\")\nfor vertex, distance in distances.items():\n    print(f\"{vertex}: {distance}\")\n\nend_vertex = 'D'\npath = reconstruct_path(previous, start_vertex, end_vertex)\nprint(f\"\\nShortest path from {start_vertex} to {end_vertex}: {' -> '.join(path)}\")\n```"
},
{
"id": "19",
"question": "Implement a function to find all permutations of a given string.",
"solution": "A permutation is an arrangement of all elements of a set in different orders.\n\n```python\ndef permutations(s):\n    # Convert string to list of characters\n    chars = list(s)\n    # Store all permutations\n    result = []\n    \n    def backtrack(start):\n        # If we've reached the end of the string, add the permutation to result\n        if start == len(chars):\n            result.append(''.join(chars))\n            return\n        \n        # Try all possible characters at the current position\n        for i in range(start, len(chars)):\n            # Swap characters at positions start and i\n            chars[start], chars[i] = chars[i], chars[start]\n            \n            # Recursively generate permutations for the remaining positions\n            backtrack(start + 1)\n            \n            # Backtrack (undo the swap)\n            chars[start], chars[i] = chars[i], chars[start]\n    \n    # Start backtracking from the first position\n    backtrack(0)\n    return result\n\n# Example usage\ns1 = \"abc\"\nperms1 = permutations(s1)\nprint(f\"Permutations of '{s1}': {perms1}\")\n\ns2 = \"AB\"\nperms2 = permutations(s2)\nprint(f\"Permutations of '{s2}': {perms2}\")\n\n# Alternative implementation using itertools\nimport itertools\n\ndef permutations_itertools(s):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nprint(f\"\\nPermutations of '{s1}' using itertools: {permutations_itertools(s1)}\")\n```"
},
{
"id": "20",
"question": "Implement a function to check if a string is a palindrome.",
"solution": "A palindrome is a string that reads the same forward and backward.\n\n```python\ndef is_palindrome(s):\n    # Convert to lowercase and remove non-alphanumeric characters\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Check if the string is equal to its reverse\n    return s == s[::-1]\n\n# Example usage\nstr1 = \"A man, a plan, a canal: Panama\"\nprint(f\"Is '{str1}' a palindrome? {is_palindrome(str1)}\")\n\nstr2 = \"race a car\"\nprint(f\"Is '{str2}' a palindrome? {is_palindrome(str2)}\")\n\n# Alternative implementation using two pointers\ndef is_palindrome_two_pointers(s):\n    # Convert to lowercase and remove non-alphanumeric characters\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Use two pointers from both ends of the string\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\nprint(f\"\\nIs '{str1}' a palindrome (using two pointers)? {is_palindrome_two_pointers(str1)}\")\n```"
},
{
"id": "21",
"question": "Implement a function to check if two strings are anagrams.",
"solution": "An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once.\n\n```python\ndef is_anagram(s, t):\n    # Check if the lengths are the same\n    if len(s) != len(t):\n        return False\n    \n    # Use a counter to track character frequencies\n    char_count = {}\n    \n    # Count characters in the first string\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Decrement counts for characters in the second string\n    for char in t:\n        if char not in char_count or char_count[char] == 0:\n            return False\n        char_count[char] -= 1\n    \n    return True\n\n# Example usage\ns1, t1 = \"anagram\", \"nagaram\"\nprint(f\"Are '{s1}' and '{t1}' anagrams? {is_anagram(s1, t1)}\")\n\ns2, t2 = \"rat\", \"car\"\nprint(f\"Are '{s2}' and '{t2}' anagrams? {is_anagram(s2, t2)}\")\n\n# Alternative implementation using Counter\nfrom collections import Counter\n\ndef is_anagram_counter(s, t):\n    return Counter(s) == Counter(t)\n\nprint(f\"\\nAre '{s1}' and '{t1}' anagrams (using Counter)? {is_anagram_counter(s1, t1)}\")\n\n# Alternative implementation using sorted strings\ndef is_anagram_sorted(s, t):\n    return sorted(s) == sorted(t)\n\nprint(f\"Are '{s1}' and '{t1}' anagrams (using sorting)? {is_anagram_sorted(s1, t1)}\")\n```"
},
{
"id": "22",
"question": "Implement a function to find the longest common prefix among an array of strings.",
"solution": "The longest common prefix is the longest string that is the prefix of all the strings in the array.\n\n```python\ndef longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    \n    # Take the first string as a reference\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the array\n    for string in strs[1:]:\n        # Reduce prefix until it matches the beginning of the current string\n        while string.find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Example usage\nstrings1 = [\"flower\", \"flow\", \"flight\"]\nprint(f\"Longest common prefix for {strings1}: '{longest_common_prefix(strings1)}'\")\n\nstrings2 = [\"dog\", \"racecar\", \"car\"]\nprint(f\"Longest common prefix for {strings2}: '{longest_common_prefix(strings2)}'\")\n\n# Alternative implementation - character by character comparison\ndef longest_common_prefix_char_by_char(strs):\n    if not strs:\n        return \"\"\n    \n    # Find the shortest string length\n    min_len = min(len(s) for s in strs)\n    \n    # Compare character by character\n    for i in range(min_len):\n        char = strs[0][i]  # Character to compare\n        \n        # Check if this character matches in all strings\n        if any(s[i] != char for s in strs):\n            return strs[0][:i]\n    \n    # If we get here, the common prefix is the shortest string\n    return strs[0][:min_len]\n\nprint(f\"\\nLongest common prefix for {strings1} (char by char): '{longest_common_prefix_char_by_char(strings1)}'\")\n```"
},
{
"id": "23",
"question": "Implement a function to find the first unique character in a string.",
"solution": "A unique character is one that appears exactly once in the string.\n\n```python\ndef first_unique_char(s):\n    # Count the occurrences of each character\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character that appears only once\n    for i, char in enumerate(s):\n        if char_count[char] == 1:\n            return i\n    \n    return -1  # No unique character found\n\n# Example usage\ns1 = \"leetcode\"\nresult1 = first_unique_char(s1)\nprint(f\"First unique character in '{s1}': index {result1}, character '{s1[result1]}'\")\n\ns2 = \"loveleetcode\"\nresult2 = first_unique_char(s2)\nprint(f\"First unique character in '{s2}': index {result2}, character '{s2[result2]}'\")\n\ns3 = \"aabb\"\nresult3 = first_unique_char(s3)\nprint(f\"First unique character in '{s3}': {result3 if result3 != -1 else 'Not found'}\")\n\n# Alternative implementation using Counter from collections\nfrom collections import Counter\n\ndef first_unique_char_counter(s):\n    # Count occurrences of each character\n    counter = Counter(s)\n    \n    # Find the first character with count 1\n    for i, char in enumerate(s):\n        if counter[char] == 1:\n            return i\n    \n    return -1\n\nprint(f\"\\nFirst unique character in '{s1}' (using Counter): index {first_unique_char_counter(s1)}\")\n```"
},
{
"id": "24",
"question": "Implement a function to validate if a given string is a valid parentheses expression.",
"solution": "A valid parentheses expression ensures that every opening bracket has a corresponding closing bracket in the correct order.\n\n```python\ndef is_valid_parentheses(s):\n    # Stack to keep track of opening brackets\n    stack = []\n    \n    # Mapping of closing to opening brackets\n    brackets_map = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    }\n    \n    # Iterate through each character in the string\n    for char in s:\n        # If it's an opening bracket, push to stack\n        if char in '({[':\n            stack.append(char)\n        # If it's a closing bracket\n        elif char in ')}]':\n            # Check if stack is empty or if the top element doesn't match\n            if not stack or stack.pop() != brackets_map[char]:\n                return False\n    \n    # If stack is empty, all brackets were matched\n    return len(stack) == 0\n\n# Example usage\ns1 = \"()\"\nprint(f\"Is '{s1}' valid? {is_valid_parentheses(s1)}\")\n\ns2 = \"()[]{}\"\nprint(f\"Is '{s2}' valid? {is_valid_parentheses(s2)}\")\n\ns3 = \"(]\"\nprint(f\"Is '{s3}' valid? {is_valid_parentheses(s3)}\")\n\ns4 = \"([)]\"\nprint(f\"Is '{s4}' valid? {is_valid_parentheses(s4)}\")\n\ns5 = \"{[]}\"\nprint(f\"Is '{s5}' valid? {is_valid_parentheses(s5)}\")\n```"
},
{
"id": "25",
"question": "Implement a function to find the maximum subarray sum.",
"solution": "The maximum subarray sum is the largest sum of a contiguous subarray within an array.\n\n```python\ndef max_subarray_sum(nums):\n    # Kadane's algorithm\n    current_sum = max_sum = nums[0]\n    \n    for num in nums[1:]:\n        # Either start a new subarray or extend the existing one\n        current_sum = max(num, current_sum + num)\n        # Update max_sum if current_sum is greater\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n# Example usage\nnums1 = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(f\"Maximum subarray sum of {nums1}: {max_subarray_sum(nums1)}\")\n\nnums2 = [5, 4, -1, 7, 8]\nprint(f\"Maximum subarray sum of {nums2}: {max_subarray_sum(nums2)}\")\n\n# Alternative implementation that also returns the subarray\ndef max_subarray(nums):\n    if not nums:\n        return 0, []\n    \n    max_sum = current_sum = nums[0]\n    max_start = max_end = start = 0\n    \n    for i, num in enumerate(nums[1:], 1):\n        if current_sum < 0:\n            # Start a new subarray\n            current_sum = num\n            start = i\n        else:\n            # Extend the existing subarray\n            current_sum += num\n        \n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start = start\n            max_end = i\n    \n    return max_sum, nums[max_start:max_end+1]\n\nmax_sum1, subarray1 = max_subarray(nums1)\nprint(f\"\\nMaximum subarray sum of {nums1}: {max_sum1}, subarray: {subarray1}\")\n```"
},


{ "id": "27", "question": "Find all pairs of elements in an array that sum to a target value.", "solution": "This is a classic two-sum problem that can be solved efficiently using a hash map.\n\n```python\ndef find_pairs(nums, target):\n    # Dictionary to store complements we've seen\n    seen = {}\n    pairs = []\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            # Found a pair\n            for j in seen[complement]:  # Handle duplicates\n                pairs.append((j, i))\n        \n        # Add current number to seen dictionary\n        if num not in seen:\n            seen[num] = []\n        seen[num].append(i)\n    \n    return pairs\n\n# Example usage\nnums = [7, 2, 11, 15, 2, 5, 10]\ntarget = 9\npairs = find_pairs(nums, target)\nprint(f\"Input array: {nums}\")\nprint(f\"Pairs that sum to {target}:\")\nfor i, j in pairs:\n    print(f\"  indices {i},{j}: {nums[i]} + {nums[j]} = {target}\")\n\n# For unique pairs (ignoring indices)\ndef find_unique_pairs(nums, target):\n    seen = set()\n    result = set()\n    \n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            # Ensure smaller number comes first in pair\n            result.add((min(num, complement), max(num, complement)))\n        seen.add(num)\n    \n    return result\n\npairs = find_unique_pairs(nums, target)\nprint(f\"\\nUnique pairs that sum to {target}:\")\nfor a, b in pairs:\n    print(f\"  {a} + {b} = {target}\")\n```\n\nTime complexity: O(n), where n is the length of the array.\nSpace complexity: O(n) for storing the hash map." }

,{ "id": "28", "question": "Implement a function to determine if a string has all unique characters.", "solution": "To check if a string has all unique characters, we can use a set or hash map to track characters we've seen.\n\n```python\ndef has_unique_chars(s):\n    # Using a set to track seen characters\n    seen = set()\n    \n    for char in s:\n        if char in seen:\n            return False\n        seen.add(char)\n    \n    return True\n\n# Example usage\ntest_strings = [\"abcdefg\", \"hello\", \"algorithm\", \"unique\"]\n\nfor s in test_strings:\n    result = has_unique_chars(s)\n    print(f\"'{s}' has all unique characters: {result}\")\n\n# Alternative implementation using Python's built-in set\ndef has_unique_chars_set(s):\n    return len(s) == len(set(s))\n\nprint(\"\\nAlternative implementation:\")\nfor s in test_strings:\n    result = has_unique_chars_set(s)\n    print(f\"'{s}' has all unique characters: {result}\")\n\n# For case-insensitive check\ndef has_unique_chars_case_insensitive(s):\n    return len(s.lower()) == len(set(s.lower()))\n\nprint(\"\\nCase-insensitive check:\")\nmixed_case = [\"AbCdEf\", \"Hello\", \"Python\"]\nfor s in mixed_case:\n    result = has_unique_chars_case_insensitive(s)\n    print(f\"'{s}' has all unique characters (case-insensitive): {result}\")\n```\n\nTime complexity: O(n), where n is the length of the string.\nSpace complexity: O(min(n, k)), where k is the size of the character set." }

,{ "id": "29", "question": "Implement a stack with a min() function that returns the minimum element in constant time.", "solution": "We can implement a stack with an O(1) min() function by using a second stack to keep track of the minimum elements.\n\n```python\nclass MinStack:\n    def __init__(self):\n        self.stack = []         # Main stack\n        self.min_stack = []     # Stack to keep track of minimums\n    \n    def push(self, val):\n        self.stack.append(val)\n        \n        # If min_stack is empty or new value is smaller than current min,\n        # add it to min_stack\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self):\n        if not self.stack:\n            return None\n        \n        val = self.stack.pop()\n        \n        # If popped value is equal to current minimum, remove from min_stack\n        if self.min_stack and val == self.min_stack[-1]:\n            self.min_stack.pop()\n            \n        return val\n    \n    def top(self):\n        if not self.stack:\n            return None\n        return self.stack[-1]\n    \n    def min(self):\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n    \n    def __str__(self):\n        return f\"Stack: {self.stack}, Current min: {self.min() if self.min_stack else 'None'}\"\n\n# Example usage\nmin_stack = MinStack()\noperations = [\n    (\"push\", 5),\n    (\"push\", 2),\n    (\"push\", 7),\n    (\"push\", 1),\n    (\"push\", 3),\n]\n\nfor op, val in operations:\n    if op == \"push\":\n        min_stack.push(val)\n        print(f\"Pushed {val}, {min_stack}\")\n\nprint(\"\\nPopping elements:\")\nwhile min_stack.stack:\n    print(f\"Before pop: {min_stack}\")\n    popped = min_stack.pop()\n    print(f\"Popped {popped}, After: {min_stack}\")\n```\n\nTime complexity: \n- push(): O(1)\n- pop(): O(1)\n- top(): O(1)\n- min(): O(1)\n\nSpace complexity: O(n) for the main stack and up to O(n) for the min_stack in the worst case." }

,{ "id": "30", "question": "Implement a function to reverse a linked list.", "solution": "Reversing a linked list is a fundamental operation that can be done iteratively or recursively.\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    \n    def __str__(self):\n        return f\"{self.val} -> {self.next}\"\n\ndef create_linked_list(values):\n    dummy = ListNode()\n    current = dummy\n    for val in values:\n        current.next = ListNode(val)\n        current = current.next\n    return dummy.next\n\n# Iterative approach\ndef reverse_list_iterative(head):\n    prev = None\n    current = head\n    \n    while current:\n        # Save next node\n        next_temp = current.next\n        \n        # Reverse the pointer\n        current.next = prev\n        \n        # Move prev and current one step forward\n        prev = current\n        current = next_temp\n    \n    # New head is prev\n    return prev\n\n# Recursive approach\ndef reverse_list_recursive(head):\n    # Base case: empty list or single node\n    if not head or not head.next:\n        return head\n    \n    # Recursive case: reverse the rest of the list\n    new_head = reverse_list_recursive(head.next)\n    \n    # Change next node's pointer to point to current node\n    head.next.next = head\n    \n    # Set current node's next to None to avoid cycles\n    head.next = None\n    \n    return new_head\n\n# Example usage\noriginal_list = create_linked_list([1, 2, 3, 4, 5])\nprint(f\"Original list: {original_list}\")\n\n# Create a copy for iterative reversal\nlist_copy1 = create_linked_list([1, 2, 3, 4, 5])\nreversed_iterative = reverse_list_iterative(list_copy1)\nprint(f\"Reversed (iterative): {reversed_iterative}\")\n\n# Create another copy for recursive reversal\nlist_copy2 = create_linked_list([1, 2, 3, 4, 5])\nreversed_recursive = reverse_list_recursive(list_copy2)\nprint(f\"Reversed (recursive): {reversed_recursive}\")\n```\n\nTime complexity: O(n), where n is the number of nodes in the linked list.\nSpace complexity: O(1) for the iterative approach and O(n) for the recursive approach due to the call stack." }

,{ "id": "31", "question": "Implement a queue using two stacks.", "solution": "We can implement a queue using two stacks. One stack is used for enqueue operations and the other for dequeue operations.\n\n```python\nclass QueueUsingStacks:\n    def __init__(self):\n        self.stack_enqueue = []  # Stack for enqueue operations\n        self.stack_dequeue = []  # Stack for dequeue operations\n    \n    def enqueue(self, val):\n        self.stack_enqueue.append(val)\n    \n    def dequeue(self):\n        # If dequeue stack is empty, transfer elements from enqueue stack\n        if not self.stack_dequeue:\n            self._transfer()\n        \n        if not self.stack_dequeue:  # Queue is empty\n            return None\n        \n        return self.stack_dequeue.pop()\n    \n    def peek(self):\n        # If dequeue stack is empty, transfer elements from enqueue stack\n        if not self.stack_dequeue:\n            self._transfer()\n        \n        if not self.stack_dequeue:  # Queue is empty\n            return None\n        \n        return self.stack_dequeue[-1]\n    \n    def _transfer(self):\n        # Transfer all elements from enqueue stack to dequeue stack\n        # This reverses the order, making the oldest element on top\n        while self.stack_enqueue:\n            self.stack_dequeue.append(self.stack_enqueue.pop())\n    \n    def is_empty(self):\n        return len(self.stack_enqueue) == 0 and len(self.stack_dequeue) == 0\n    \n    def size(self):\n        return len(self.stack_enqueue) + len(self.stack_dequeue)\n    \n    def __str__(self):\n        # For display purposes\n        elements = self.stack_dequeue[::-1] + self.stack_enqueue\n        return f\"Queue: {elements} (front -> rear)\"\n\n# Example usage\nqueue = QueueUsingStacks()\nprint(f\"Initial: {queue}\")\n\n# Enqueue operations\nfor i in range(1, 6):\n    queue.enqueue(i)\n    print(f\"Enqueued {i}: {queue}\")\n\n# Dequeue operations\nprint(\"\\nDequeue operations:\")\nwhile not queue.is_empty():\n    front = queue.peek()\n    print(f\"Front element: {front}\")\n    dequeued = queue.dequeue()\n    print(f\"Dequeued {dequeued}: {queue}\")\n```\n\nTime complexity:\n- enqueue(): O(1) amortized\n- dequeue(): O(1) amortized (although individual operations might be O(n) when transfer is needed)\n- peek(): O(1) amortized\n\nSpace complexity: O(n) for storing the elements." }

,{ "id": "32", "question": "Design an algorithm to check if a binary tree is balanced.", "solution": "A balanced binary tree is one where the height difference between the left and right subtrees of any node is at most 1. We can use a post-order traversal approach.\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_balanced(root):\n    # Helper function returns (is_balanced, height)\n    def check_height(node):\n        if not node:\n            return True, 0\n        \n        # Check left subtree\n        left_balanced, left_height = check_height(node.left)\n        if not left_balanced:\n            return False, 0\n        \n        # Check right subtree\n        right_balanced, right_height = check_height(node.right)\n        if not right_balanced:\n            return False, 0\n        \n        # Check if current node is balanced\n        is_current_balanced = abs(left_height - right_height) <= 1\n        \n        # Calculate height of current subtree\n        current_height = max(left_height, right_height) + 1\n        \n        return is_current_balanced, current_height\n    \n    # Start the recursion from the root\n    balanced, _ = check_height(root)\n    return balanced\n\n# Example usage\n# Balanced tree\n#      1\n#     / \\\n#    2   3\n#   / \\\n#  4   5\nbalanced_tree = TreeNode(1,\n                         TreeNode(2,\n                                  TreeNode(4),\n                                  TreeNode(5)),\n                         TreeNode(3))\n\n# Unbalanced tree\n#      1\n#     / \\\n#    2   3\n#   /\n#  4\n#  /\n# 5\nunbalanced_tree = TreeNode(1,\n                           TreeNode(2,\n                                    TreeNode(4,\n                                             TreeNode(5)),\n                                    None),\n                           TreeNode(3))\n\nprint(f\"Balanced tree is balanced: {is_balanced(balanced_tree)}\")\nprint(f\"Unbalanced tree is balanced: {is_balanced(unbalanced_tree)}\")\n```\n\nTime complexity: O(n), where n is the number of nodes in the tree, as we visit each node exactly once.\nSpace complexity: O(h), where h is the height of the tree, used by the recursion stack. In the worst case, this could be O(n) for a skewed tree." }

,{ "id": "33", "question": "Implement a function to check if a binary tree is a binary search tree (BST).", "solution": "A binary search tree has the property that all nodes in the left subtree are less than the current node, and all nodes in the right subtree are greater than the current node.\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Approach 1: Recursive approach with min-max range\ndef is_valid_bst(root):\n    def validate(node, lower=float('-inf'), upper=float('inf')):\n        if not node:\n            return True\n        \n        # Check if current node's value is within valid range\n        if node.val <= lower or node.val >= upper:\n            return False\n        \n        # Recursively check left subtree (all values must be < node.val)\n        # and right subtree (all values must be > node.val)\n        return (validate(node.left, lower, node.val) and\n                validate(node.right, node.val, upper))\n    \n    return validate(root)\n\n# Approach 2: Inorder traversal (values should be in ascending order)\ndef is_valid_bst_inorder(root):\n    inorder_values = []\n    \n    def inorder_traversal(node):\n        if not node:\n            return\n        \n        inorder_traversal(node.left)\n        inorder_values.append(node.val)\n        inorder_traversal(node.right)\n    \n    inorder_traversal(root)\n    \n    # Check if the values are in ascending order\n    for i in range(1, len(inorder_values)):\n        if inorder_values[i] <= inorder_values[i-1]:\n            return False\n    \n    return True\n\n# Example usage\n# Valid BST\n#      5\n#     / \\\n#    3   7\n#   / \\ / \\\n#  2  4 6  8\nvalid_bst = TreeNode(5,\n                     TreeNode(3,\n                              TreeNode(2),\n                              TreeNode(4)),\n                     TreeNode(7,\n                              TreeNode(6),\n                              TreeNode(8)))\n\n# Invalid BST (6 is in wrong position)\n#      5\n#     / \\\n#    3   7\n#   / \\ / \\\n#  2  6 4  8\ninvalid_bst = TreeNode(5,\n                       TreeNode(3,\n                                TreeNode(2),\n                                TreeNode(6)),  # 6 > 5, violates BST property\n                       TreeNode(7,\n                                TreeNode(4),  # 4 < 5, violates BST property\n                                TreeNode(8)))\n\nprint(f\"Valid BST check (approach 1): {is_valid_bst(valid_bst)}\")\nprint(f\"Invalid BST check (approach 1): {is_valid_bst(invalid_bst)}\")\n\nprint(f\"Valid BST check (approach 2): {is_valid_bst_inorder(valid_bst)}\")\nprint(f\"Invalid BST check (approach 2): {is_valid_bst_inorder(invalid_bst)}\")\n```\n\nTime complexity: O(n) for both approaches, where n is the number of nodes in the tree.\nSpace complexity: O(h) for approach 1 and O(n) for approach 2, where h is the height of the tree." }

,{ "id": "34", "question": "Implement a function to find the first common ancestor of two nodes in a binary tree.", "solution": "Finding the lowest common ancestor (LCA) in a binary tree can be approached in different ways depending on available information.\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Approach 1: When we don't have parent pointers\ndef find_lca(root, p, q):\n    # Base case\n    if not root or root == p or root == q:\n        return root\n    \n    # Search in left and right subtrees\n    left = find_lca(root.left, p, q)\n    right = find_lca(root.right, p, q)\n    \n    # If both nodes are found in different subtrees, root is the LCA\n    if left and right:\n        return root\n    \n    # Otherwise, return the non-null value\n    return left if left else right\n\n# Approach 2: When we have parent pointers\nclass TreeNodeWithParent:\n    def __init__(self, val=0, left=None, right=None, parent=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.parent = parent\n\ndef find_lca_with_parent(p, q):\n    # Track ancestors of p\n    ancestors = set()\n    \n    # Add all ancestors of p to the set\n    while p:\n        ancestors.add(p)\n        p = p.parent\n    \n    # Find the first ancestor of q that's also an ancestor of p\n    while q not in ancestors:\n        q = q.parent\n    \n    return q\n\n# Example usage\n# Create a binary tree\n#      1\n#     / \\\n#    2   3\n#   / \\ / \\\n#  4  5 6  7\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\n\n# Find LCA of nodes with values 4 and 5\nlca = find_lca(root, root.left.left, root.left.right)\nprint(f\"LCA of 4 and 5 is: {lca.val}\")  # Should be 2\n\n# Find LCA of nodes with values 4 and 6\nlca = find_lca(root, root.left.left, root.right.left)\nprint(f\"LCA of 4 and 6 is: {lca.val}\")  # Should be 1\n\n# Example with parent pointers\np_root = TreeNodeWithParent(1)\np_root.left = TreeNodeWithParent(2, parent=p_root)\np_root.right = TreeNodeWithParent(3, parent=p_root)\np_root.left.left = TreeNodeWithParent(4, parent=p_root.left)\np_root.left.right = TreeNodeWithParent(5, parent=p_root.left)\np_root.right.left = TreeNodeWithParent(6, parent=p_root.right)\np_root.right.right = TreeNodeWithParent(7, parent=p_root.right)\n\nlca_p = find_lca_with_parent(p_root.left.left, p_root.left.right)\nprint(f\"\\nLCA with parent pointers (4 and 5): {lca_p.val}\")  # Should be 2\n\nlca_p = find_lca_with_parent(p_root.left.left, p_root.right.left)\nprint(f\"LCA with parent pointers (4 and 6): {lca_p.val}\")  # Should be 1\n```\n\nTime complexity:\n- Approach 1: O(n), where n is the number of nodes in the tree.\n- Approach 2: O(h), where h is the height of the tree, as we traverse at most the height of the tree for each node.\n\nSpace complexity:\n- Approach 1: O(h) for the recursion stack.\n- Approach 2: O(h) for storing ancestors of one node." }

,{ "id": "35", "question": "Given a sorted array of integers, find the starting and ending position of a given target value.", "solution": "To find the starting and ending positions of a target value in a sorted array, we can use binary search twice: once to find the leftmost occurrence and once to find the rightmost occurrence.\n\n```python\ndef search_range(nums, target):\n    # Helper function to find the leftmost position\n    def find_left(nums, target):\n        left, right = 0, len(nums) - 1\n        result = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                result = mid  # Found target, but continue searching left\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return result\n    \n    # Helper function to find the rightmost position\n    def find_right(nums, target):\n        left, right = 0, len(nums) - 1\n        result = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                result = mid  # Found target, but continue searching right\n                left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return result\n    \n    # Empty array check\n    if not nums:\n        return [-1, -1]\n    \n    left_pos = find_left(nums, target)\n    \n    # If target not found, return [-1, -1]\n    if left_pos == -1:\n        return [-1, -1]\n    \n    right_pos = find_right(nums, target)\n    \n    return [left_pos, right_pos]\n\n# Example usage\ntest_cases = [\n    ([5, 7, 7, 8, 8, 10], 8),\n    ([5, 7, 7, 8, 8, 10], 6),\n    ([1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 5], 3),\n    ([], 0),\n    ([1], 1),\n]\n\nfor nums, target in test_cases:\n    result = search_range(nums, target)\n    print(f\"Array: {nums}\\nTarget: {target}\\nRange: {result}\\n\")\n\n# Alternative implementation using Python's bisect module\nimport bisect\n\ndef search_range_bisect(nums, target):\n    # Find the leftmost insertion point for target\n    left = bisect.bisect_left(nums, target)\n    \n    # If target not in array or array is empty\n    if left == len(nums) or nums[left] != target:\n        return [-1, -1]\n    \n    # Find the rightmost insertion point for target+1 and subtract 1\n    right = bisect.bisect_right(nums, target) - 1\n    \n    return [left, right]\n\nprint(\"Using bisect module:\")\nfor nums, target in test_cases:\n    result = search_range_bisect(nums, target)\n    print(f\"Array: {nums}\\nTarget: {target}\\nRange: {result}\\n\")\n```\n\nTime complexity: O(log n), where n is the length of the array, as we perform two binary searches.\nSpace complexity: O(1), as we only use constant extra space." }

,{ "id": "36", "question": "Implement a trie (prefix tree) data structure.", "solution": "A trie is a tree-like data structure used for efficient retrieval of keys in a dataset of strings. It's especially useful for dictionary lookups and prefix matching.\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}  # Dictionary to store child nodes\n        self.is_end_of_word = False  # Flag to indicate end of a word\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        \"\"\"\n        Insert a word into the trie\n        \"\"\"\n        current = self.root\n        \n        for char in word:\n            # If character not in current's children, add it\n            if char not in current.children:\n                current.children[char] = TrieNode()\n            # Move to the next node\n            current = current.children[char]\n        \n        # Mark the end of the word\n        current.is_end_of_word = True\n    \n    def search(self, word):\n        \"\"\"\n        Return True if the word is in the trie\n        \"\"\"\n        current = self.root\n        \n        for char in word:\n            # If character not found, word is not in trie\n            if char not in current.children:\n                return False\n            # Move to the next node\n            current = current.children[char]\n        \n        # Return whether this node is the end of a word\n        return current.is_end_of_word\n    \n    def starts_with(self, prefix):\n        \"\"\"\n        Return True if there is any word in the trie that starts with the given prefix\n        \"\"\"\n        current = self.root\n        \n        for char in prefix:\n            # If character not found, no word with this prefix\n            if char not in current.children:\n                return False\n            # Move to the next node\n            current = current.children[char]\n        \n        # We've found the prefix\n        return True\n    \n    def get_words_with_prefix(self, prefix):\n        \"\"\"\n        Return all words in the trie that start with the given prefix\n        \"\"\"\n        result = []\n        current = self.root\n        \n        # Navigate to the node corresponding to the prefix\n        for char in prefix:\n            if char not in current.children:\n                return result  # Prefix not in trie\n            current = current.children[char]\n        \n        # Use DFS to find all words with the prefix\n        self._find_words(current, prefix, result)\n        \n        return result\n    \n    def _find_words(self, node, prefix, result):\n        \"\"\"\n        Helper method to find all words with a given prefix using DFS\n        \"\"\"\n        if node.is_end_of_word:\n            result.append(prefix)\n        \n        for char, child in node.children.items():\n            self._find_words(child, prefix + char, result)\n\n# Example usage\ntrie = Trie()\n\n# Insert words\nwords = [\"apple\", \"app\", \"apricot\", \"banana\", \"bat\", \"bath\"]\nfor word in words:\n    trie.insert(word)\n\n# Search for words\ntest_words = [\"apple\", \"app\", \"apricot\", \"orange\", \"bat\"]\nprint(\"Search results:\")\nfor word in test_words:\n    print(f\"'{word}' in trie: {trie.search(word)}\")\n\n# Test prefix search\nprefixes = [\"ap\", \"ba\", \"or\", \"b\"]\nprint(\"\\nPrefix search results:\")\nfor prefix in prefixes:\n    print(f\"Words with prefix '{prefix}': {trie.get_words_with_prefix(prefix)}\")\n\n# Test starts_with\nprint(\"\\nStarts with tests:\")\nfor prefix in prefixes:\n    print(f\"Trie contains words starting with '{prefix}': {trie.starts_with(prefix)}\")\n```\n\nTime complexity:\n- insert(): O(m), where m is the length of the word being inserted.\n- search(): O(m), where m is the length of the word being searched.\n- starts_with(): O(m), where m is the length of the prefix.\n- get_words_with_prefix(): O(n), where n is the number of nodes in the trie (in the worst case).\n\nSpace complexity: O(ALPHABET_SIZE * m * n), where m is the average length of words and n is the number of words in the trie. The ALPHABET_SIZE is the number of possible characters (26 for lowercase English alphabet, 128 for ASCII, etc.)." }

,{ "id": "37", "question": "Implement an LRU (Least Recently Used) cache.", "solution": "An LRU cache is a data structure that maintains a fixed size cache by removing the least recently used items when the cache reaches its capacity. We can implement it using a combination of a hash map and a doubly linked list.\n\n```python\nclass DLLNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}  # Hash map for O(1) lookup\n        \n        # Initialize dummy head and tail nodes\n        self.head = DLLNode()  # Most recently used\n        self.tail = DLLNode()  # Least recently used\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def _add_node(self, node):\n        \"\"\"\n        Always add the new node right after head (most recently used)\n        \"\"\"\n        node.prev = self.head\n        node.next = self.head.next\n        \n        self.head.next.prev = node\n        self.head.next = node\n    \n    def _remove_node(self, node):\n        \"\"\"\n        Remove an existing node from the linked list\n        \"\"\"\n        prev = node.prev\n        next_node = node.next\n        \n        prev.next = next_node\n        next_node.prev = prev\n    \n    def _move_to_head(self, node):\n        \"\"\"\n        Move certain node to the head (mark as recently used)\n        \"\"\"\n        self._remove_node(node)\n        self._add_node(node)\n    \n    def _pop_tail(self):\n        \"\"\"\n        Pop the tail node (least recently used)\n        \"\"\"\n        res = self.tail.prev\n        self._remove_node(res)\n        return res\n    \n    def get(self, key):\n        \"\"\"\n        Get the value of the key if it exists, otherwise return -1\n        Update the position to mark as recently used\n        \"\"\"\n        if key in self.cache:\n            node = self.cache[key]\n            self._move_to_head(node)  # Update to most recently used\n            return node.value\n        return -1\n    \n    def put(self, key, value):\n        \"\"\"\n        Update or insert the value if the key exists.\n        When the cache reaches its capacity, evict the least recently used key.\n        \"\"\"\n        if key in self.cache:\n            # Update existing key\n            node = self.cache[key]\n            node.value = value\n            self._move_to_head(node)\n        else:\n            # Insert new key\n            new_node = DLLNode(key, value)\n            self.cache[key] = new_node\n            self._add_node(new_node)\n            \n            # Check capacity\n            if len(self.cache) > self.capacity:\n                # Remove the least recently used item\n                tail_node = self._pop_tail()\n                del self.cache[tail_node.key]\n    \n    def __str__(self):\n        values = []\n        current = self.head.next\n        while current != self.tail:\n            values.append(f\"({current.key}: {current.value})\")\n            current = current.next\n        return \"[\" + \" -> \".join(values) + \"]\"\n\n# Example usage\ncache = LRUCache(3)  # Create a cache with capacity 3\n\noperations = [\n    (\"put\", 1, 1),\n    (\"put\", 2, 2),\n    (\"put\", 3, 3),\n    (\"get\", 1),\n    (\"put\", 4, 4),  # This should evict key 2\n    (\"get\", 2),\n    (\"get\", 3),\n    (\"get\", 4),\n    (\"put\", 5, 5),  # This should evict key 1\n    (\"get\", 1),\n    (\"get\", 3),\n    (\"get\", 5),\n    (\"put\", 3, 33),  # Update existing key\n]\n\nfor op in operations:\n    if op[0] == \"put\":\n        key, value = op[1], op[2]\n        cache.put(key, value)\n        print(f\"Put ({key}, {value}) -> {cache}\")\n    else:  # get\n        key = op[1]\n        result = cache.get(key)\n        print(f\"Get {key} -> {result}, Cache: {cache}\")\n```\n\nTime complexity:\n- get(): O(1)\n- put(): O(1)\n\nSpace complexity: O(capacity), as we store at most `capacity` number of key-value pairs." }

,{ "id": "38", "question": "Find the kth largest element in an unsorted array.", "solution": "We can find the kth largest element in an unsorted array using different approaches, such as sorting, using a heap, or using the quickselect algorithm.\n\n```python\ndef find_kth_largest(nums, k):\n    \"\"\"\n    Find the kth largest element using Python's built-in sorting\n    \"\"\"\n    return sorted(nums, reverse=True)[k-1]\n\ndef find_kth_largest_heap(nums, k):\n    \"\"\"\n    Find the kth largest element using a min-heap of size k\n    \"\"\"\n    import heapq\n    \n    # Create a min-heap of size k\n    min_heap = nums[:k]\n    heapq.heapify(min_heap)\n    \n    # Process remaining elements\n    for num in nums[k:]:\n        if num > min_heap[0]:  # If current element > smallest in heap\n            heapq.heappop(min_heap)  # Remove smallest\n            heapq.heappush(min_heap, num)  # Add current element\n    \n    # The smallest element in the heap is the kth largest\n    return min_heap[0]\n\ndef find_kth_largest_quickselect(nums, k):\n    \"\"\"\n    Find the kth largest element using quickselect algorithm\n    \"\"\"\n    def partition(nums, left, right, pivot_index):\n        pivot = nums[pivot_index]\n        # Move pivot to the end\n        nums[pivot_index], nums[right] = nums[right], nums[pivot_index]\n        \n        # Move all elements smaller than pivot to the left\n        store_index = left\n        for i in range(left, right):\n            if nums[i] < pivot:\n                nums[i], nums[store_index] = nums[store_index], nums[i]\n                store_index += 1\n        \n        # Move pivot to its final position\n        nums[store_index], nums[right] = nums[right], nums[store_index]\n        \n        return store_index\n    \n    def select(nums, left, right, k_smallest):\n        \"\"\"\n        Returns the k-smallest element within nums[left...right]\n        \"\"\"\n        if left == right:  # Only one element\n            return nums[left]\n        \n        # Select a random pivot\n        import random\n        pivot_index = random.randint(left, right)\n        \n        # Find the pivot position in a sorted array\n        pivot_index = partition(nums, left, right, pivot_index)\n        \n        # If the pivot is in its final sorted position\n        if k_smallest == pivot_index:\n            return nums[k_smallest]\n        elif k_smallest < pivot_index:\n            # Search in the left subarray\n            return select(nums, left, pivot_index - 1, k_smallest)\n        else:\n            # Search in the right subarray\n            return select(nums, pivot_index + 1, right, k_smallest)\n    \n    # We want to find the kth largest, which is (n-k)th smallest\n    return select(nums.copy(), 0, len(nums) - 1, len(nums) - k)\n\n# Example usage\ntest_cases = [\n    ([3, 2, 1, 5, 6, 4], 2),  # 2nd largest is 5\n    ([3, 2, 3, 1, 2, 4, 5, 5, 6], 4),  # 4th largest is 4\n    ([7, 6, 5, 4, 3, 2, 1], 3),  # 3rd largest is 5\n]\n\nfor nums, k in test_cases:\n    print(f\"Array: {nums}\\nk: {k}\")\n    print(f\"kth largest (sorting): {find_kth_largest(nums, k)}\")\n    print(f\"kth largest (heap): {find_kth_largest_heap(nums, k)}\")\n    print(f\"kth largest (quickselect): {find_kth_largest_quickselect(nums, k)}\\n\")\n```\n\nTime complexity:\n- Sorting approach: O(n log n)\n- Heap approach: O(n log k)\n- Quickselect approach: O(n) on average, O(n) worst case\n\nSpace complexity:\n- Sorting approach: O(n) for the sorted array\n- Heap approach: O(k) for the heap\n- Quickselect approach: O(1) if done in-place (ignoring recursion stack)" }

,{ "id": "39", "question": "Implement a function to determine if a string is a palindrome, considering only alphanumeric characters and ignoring case.", "solution": "A palindrome is a string that reads the same backward as forward. We need to check if a string is a palindrome while ignoring non-alphanumeric characters and case sensitivity.\n\n```python\ndef is_palindrome(s):\n    \"\"\"\n    Determine if a string is a palindrome, considering only alphanumeric\n    characters and ignoring case.\n    \"\"\"\n    # Convert to lowercase and filter out non-alphanumeric characters\n    filtered_chars = [char.lower() for char in s if char.isalnum()]\n    \n    # Check if it's a palindrome using two pointers\n    left, right = 0, len(filtered_chars) - 1\n    \n    while left < right:\n        if filtered_chars[left] != filtered_chars[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\n# Alternative approach without filtering first\ndef is_palindrome_two_pointers(s):\n    \"\"\"\n    Two-pointer approach directly on the original string.\n    \"\"\"\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Skip non-alphanumeric characters from left\n        while left < right and not s[left].isalnum():\n            left += 1\n        \n        # Skip non-alphanumeric characters from right\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        # Compare characters (case-insensitive)\n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True\n\n# Alternative using Python's built-in functions\ndef is_palindrome_pythonic(s):\n    \"\"\"\n    Pythonic way to check if a string is a palindrome.\n    \"\"\"\n    # Filter and convert to lowercase\n    filtered_s = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Check if the string equals its reverse\n    return filtered_s == filtered_s[::-1]\n\n# Example usage\ntest_strings = [\n    \"A man, a plan, a canal: Panama\",\n    \"race a car\",\n    \"Was it a car or a cat I saw?\",\n    \"No 'x' in Nixon\",\n    \"Never odd or even\",\n    \"Hello, world!\",\n    \"\",  # Empty string\n    \"a\"   # Single character\n]\n\nfor s in test_strings:\n    print(f\"String: \\\"{s}\\\"\")\n    print(f\"Is palindrome (method 1): {is_palindrome(s)}\")\n    print(f\"Is palindrome (method 2): {is_palindrome_two_pointers(s)}\")\n    print(f\"Is palindrome (pythonic): {is_palindrome_pythonic(s)}\\n\")\n```\n\nTime complexity: O(n), where n is the length of the string. We process each character at most once.\nSpace complexity: O(n) for the first and third methods (for storing filtered characters), and O(1) for the second method as it uses constant extra space." }

,{ "id": "40", "question": "Merge two sorted linked lists into a single sorted linked list.", "solution": "Merging two sorted linked lists is a common operation that can be implemented iteratively or recursively.\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    \n    def __str__(self):\n        result = []\n        current = self\n        while current:\n            result.append(str(current.val))\n            current = current.next\n        return \" -> \".join(result)\n\ndef create_linked_list(values):\n    dummy = ListNode()\n    current = dummy\n    for val in values:\n        current.next = ListNode(val)\n        current = current.next\n    return dummy.next\n\n# Iterative approach\ndef merge_two_lists_iterative(l1, l2):\n    # Dummy node to simplify code\n    dummy = ListNode()\n    current = dummy\n    \n    # Iterate while both lists have nodes\n    while l1 and l2:\n        if l1.val <= l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    \n    # Attach the remaining nodes of l1 or l2\n    current.next = l1 if l1 else l2\n    \n    return dummy.next\n\n# Recursive approach\ndef merge_two_lists_recursive(l1, l2):\n    # Base cases\n    if not l1:\n        return l2\n    if not l2:\n        return l1\n    \n    # Recursive case\n    if l1.val <= l2.val:\n        l1.next = merge_two_lists_recursive(l1.next, l2)\n        return l1\n    else:\n        l2.next = merge_two_lists_recursive(l1, l2.next)\n        return l2\n\n# Example usage\nlist1 = create_linked_list([1, 3, 5, 7, 9])\nlist2 = create_linked_list([2, 4, 6, 8, 10])\n\nprint(f\"List 1: {list1}\")\nprint(f\"List 2: {list2}\")\n\n# Create copies for both approaches\nlist1_copy1 = create_linked_list([1, 3, 5, 7, 9])\nlist2_copy1 = create_linked_list([2, 4, 6, 8, 10])\n\nlist1_copy2 = create_linked_list([1, 3, 5, 7, 9])\nlist2_copy2 = create_linked_list([2, 4, 6, 8, 10])\n\n# Merge using iterative approach\nmerged_iterative = merge_two_lists_iterative(list1_copy1, list2_copy1)\nprint(f\"\\nMerged (iterative): {merged_iterative}\")\n\n# Merge using recursive approach\nmerged_recursive = merge_two_lists_recursive(list1_copy2, list2_copy2)\nprint(f\"Merged (recursive): {merged_recursive}\")\n\n# Test with uneven lists\nlist3 = create_linked_list([1, 2, 4])\nlist4 = create_linked_list([1, 3, 4, 5, 6])\n\nprint(f\"\\nList 3: {list3}\")\nprint(f\"List 4: {list4}\")\n\nmerged_uneven = merge_two_lists_iterative(list3, list4)\nprint(f\"Merged uneven lists: {merged_uneven}\")\n```\n\nTime complexity: O(n+m), where n and m are the lengths of the two input linked lists. We need to visit each node exactly once.\n\nSpace complexity: \n- Iterative approach: O(1), as we only use a constant amount of extra space.\n- Recursive approach: O(n+m) due to the recursion stack." }

];