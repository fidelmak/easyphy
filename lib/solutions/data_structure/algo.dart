final List<Map<String, String>> algoData = [
{
"id": "1",
"category": "Searching",
"question": "What is the time complexity of searching for an element in a sorted array using binary search?",
"solution": "The time complexity of binary search is O(log n), where n is the size of the array.\n\n```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1  # Element not found\n\n# Example usage\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ntarget = 7\nresult = binary_search(arr, target)\nprint(f\"Element found at index: {result}\")\n```"
},
{
"id": "2",
"category": "Linked Lists",
"question": "How do you reverse a linked list in-place?",
"solution": "To reverse a linked list in-place, we need to change the direction of all pointers using three pointers: current, previous, and next.\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_linked_list(head):\n    prev = None\n    current = head\n    \n    while current:\n        next_temp = current.next  # Store next node\n        current.next = prev       # Reverse the pointer\n        prev = current            # Move prev forward\n        current = next_temp       # Move current forward\n    \n    return prev  # New head of the reversed list\n\n# Example usage\ndef print_linked_list(head):\n    current = head\n    values = []\n    while current:\n        values.append(str(current.val))\n        current = current.next\n    print(' -> '.join(values))\n\n# Create a linked list: 1 -> 2 -> 3 -> 4 -> 5\nhead = ListNode(1)\nhead.next = ListNode(2)\nhead.next.next = ListNode(3)\nhead.next.next.next = ListNode(4)\nhead.next.next.next.next = ListNode(5)\n\nprint(\"Original linked list:\")\nprint_linked_list(head)\n\n# Reverse the linked list\nreversed_head = reverse_linked_list(head)\n\nprint(\"Reversed linked list:\")\nprint_linked_list(reversed_head)\n```"
},
{
"id": "3",
"category": "Arrays",
"question": "How do you find the maximum subarray sum in an array of integers?",
"solution": "We can use Kadane's algorithm to find the maximum subarray sum in O(n) time.\n\n```python\ndef max_subarray_sum(nums):\n    if not nums:\n        return 0\n       "
" current_sum = max_sum = nums[0] \n "
" \n for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n "
" return max_sum\n\n# Example usage\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nresult = max_subarray_sum(nums)\nprint(f\"Maximum subarray sum: {result}\")  # Output: 6 (from subarray [4, -1, 2, 1])\n```"
},
{
"id": "4",
"category": "Sorting",
"question": "Implement the merge sort algorithm for an array of integers",
"solution": "Merge sort is a divide-and-conquer algorithm with O(n log n) time complexity.\n\n```python\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr \n       "
"\n mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n   "
"return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n "
" while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1 "
" result.extend(left[i:])\n    result.extend(right[j:])\n "
" return result\n\n# Example usage\narr = [38, 27, 43, 3, 9, 82, 10]\nsorted_arr = merge_sort(arr)\nprint(f\"Sorted array: {sorted_arr}\")\n```"
},
{
"id": "5",
"category": "Trees",
"question": "How do you perform an in-order traversal of a binary tree?",
"solution": "In-order traversal visits left subtree, then root, then right subtree.\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorder_traversal_recursive(root):\n    result = []\n    \n    def inorder(node):\n        if not node:\n            return\n        inorder(node.left)      # Visit left subtree\n        result.append(node.val) # Visit root\n        inorder(node.right)     # Visit right subtree\n    \n    inorder(root)\n    return result\n\ndef inorder_traversal_iterative(root):\n    result = []\n    stack = []\n    current = root\n    \n    while current or stack:\n        # Reach the leftmost node\n        while current:\n            stack.append(current)\n            current = current.left\n        \n        # Current is now None, pop from stack\n        current = stack.pop()\n        result.append(current.val)\n        \n        # Visit right subtree\n        current = current.right\n    \n    return result\n\n# Example usage\nroot = TreeNode(1)\nroot.right = TreeNode(2)\nroot.right.left = TreeNode(3)\n\nprint(\"Recursive in-order traversal:\", inorder_traversal_recursive(root))\nprint(\"Iterative in-order traversal:\", inorder_traversal_iterative(root))\n```"
},
{
"id": "6",
"category": "Graphs",
"question": "Implement Breadth-First Search (BFS) for a graph",
"solution": "BFS traverses a graph level by level using a queue.\n\n```python\nfrom collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n    \n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n    \n    def bfs(self, start):\n        # Mark all vertices as not visited\n        visited = set()\n        result = []\n        \n        # Create a queue for BFS\n        queue = deque([start])\n        visited.add(start)\n        \n        while queue:\n            # Dequeue a vertex from queue\n            vertex = queue.popleft()\n            result.append(vertex)\n            \n            # Get all adjacent vertices of the dequeued vertex\n            # If an adjacent hasn't been visited, mark it visited and enqueue it\n            for neighbor in self.graph[vertex]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        return result\n\n# Example usage\ng = Graph()\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\n\nprint(\"BFS traversal starting from vertex 2:\")\nprint(g.bfs(2))\n```"
},
{
"id": "7",
"category": "Graphs",
"question": "Implement Depth-First Search (DFS) for a graph",
"solution": "DFS explores as far as possible along each branch before backtracking.\n\n```python\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n    \n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n    \n    def dfs_recursive(self, start):\n        visited = set()\n        result = []\n        \n        def dfs_util(vertex):\n            visited.add(vertex)\n            result.append(vertex)\n            \n            for neighbor in self.graph[vertex]:\n                if neighbor not in visited:\n                    dfs_util(neighbor)\n        \n        dfs_util(start)\n        return result\n    \n    def dfs_iterative(self, start):\n        visited = set()\n        result = []\n        stack = [start]\n        \n        while stack:\n            vertex = stack.pop()\n            \n            if vertex not in visited:\n                visited.add(vertex)\n                result.append(vertex)\n                \n                # Add neighbors in reverse order to get same result as recursive\n                for neighbor in reversed(self.graph[vertex]):\n                    if neighbor not in visited:\n                        stack.append(neighbor)\n        \n        return result\n\n# Example usage\ng = Graph()\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\n\nprint(\"Recursive DFS traversal starting from vertex 2:\")\nprint(g.dfs_recursive(2))\n\nprint(\"Iterative DFS traversal starting from vertex 2:\")\nprint(g.dfs_iterative(2))\n```"
},
{
"id": "8",
"category": "Dynamic Programming",
"question": "Solve the fibonacci sequence problem using dynamic programming",
"solution": "Dynamic programming optimizes recursive algorithms by storing intermediate results.\n\n```python\n# Recursive approach (inefficient)\ndef fibonacci_recursive(n):\n    if n <= 1:\n        return n\n    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)\n\n# Top-down approach with memoization\ndef fibonacci_memoization(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    \n    memo[n] = fibonacci_memoization(n-1, memo) + fibonacci_memoization(n-2, memo)\n    return memo[n]\n\n# Bottom-up approach with tabulation\ndef fibonacci_tabulation(n):\n    if n <= 1:\n        return n\n        \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n\n# Space-optimized approach\ndef fibonacci_optimized(n):\n    if n <= 1:\n        return n\n        \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b\n\n# Example usage\nn = 10\nprint(f\"Fibonacci({n}) recursive:\", fibonacci_recursive(n))\nprint(f\"Fibonacci({n}) memoization:\", fibonacci_memoization(n))\nprint(f\"Fibonacci({n}) tabulation:\", fibonacci_tabulation(n))\nprint(f\"Fibonacci({n}) optimized:\", fibonacci_optimized(n))\n```"
},
{
"id": "9",
"category": "Dynamic Programming",
"question": "Solve the 0/1 Knapsack problem using dynamic programming",
"solution": "The 0/1 Knapsack problem is a classic dynamic programming problem.\n\n```python\ndef knapsack_01(weights, values, capacity):\n    n = len(weights)\n    # Initialize DP table with 0s\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    # Build table in bottom-up manner\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            # If current item weight is greater than capacity, skip it\n            if weights[i-1] > w:\n                dp[i][w] = dp[i-1][w]\n            else:\n                # Max of (including current item, excluding current item)\n                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])\n    \n    # Reconstruct the solution\n    selected_items = []\n    i, j = n, capacity\n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i-1][j]:\n            selected_items.append(i-1)\n            j -= weights[i-1]\n        i -= 1\n    \n    return dp[n][capacity], selected_items\n\n# Example usage\nvalues = [60, 100, 120]\nweights = [10, 20, 30]\ncapacity = 50\n\nmax_value, selected = knapsack_01(weights, values, capacity)\nprint(f\"Maximum value: {max_value}\")\nprint(f\"Selected items (0-indexed): {selected}\")\n```"
},
{
"id": "10",
"category": "Greedy Algorithms",
"question": "Implement a solution for the activity selection problem",
"solution": "The activity selection problem can be solved using a greedy approach.\n\n```python\ndef activity_selection(start_times, finish_times):\n    # Create a list of activities with start and finish times\n    activities = list(zip(start_times, finish_times))\n    \n    # Sort activities by finish time\n    activities.sort(key=lambda x: x[1])\n    \n    selected = [0]  # First activity is always selected\n    last_finish_time = activities[0][1]\n    \n    for i in range(1, len(activities)):\n        # If this activity starts after the previous selected activity finishes\n        if activities[i][0] >= last_finish_time:\n            selected.append(i)\n            last_finish_time = activities[i][1]\n    \n    return selected\n\n# Example usage\nstart_times = [1, 3, 0, 5, 8, 5]\nfinish_times = [2, 4, 6, 7, 9, 9]\n\nselected_activities = activity_selection(start_times, finish_times)\nprint(\"Selected activities (0-indexed):\", selected_activities)\n\nfor idx in selected_activities:\n    print(f\"Activity {idx}: Start at {start_times[idx]}, Finish at {finish_times[idx]}\")\n```"
},
{
"id": "11",
"category": "Heaps",
"question": "Implement a priority queue using a binary heap",
"solution": "A priority queue can be efficiently implemented using a binary heap.\n\n```python\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i):\n        return (i - 1) // 2\n    \n    def left_child(self, i):\n        return 2 * i + 1\n    \n    def right_child(self, i):\n        return 2 * i + 2\n    \n    def get_min(self):\n        if not self.heap:\n            return None\n        return self.heap[0]\n    \n    def extract_min(self):\n        if not self.heap:\n            return None\n        \n        min_val = self.heap[0]\n        last_val = self.heap.pop()\n        \n        if self.heap:  # If heap is not empty after popping\n            self.heap[0] = last_val\n            self._sift_down(0)\n        \n        return min_val\n    \n    def insert(self, val):\n        self.heap.append(val)\n        self._sift_up(len(self.heap) - 1)\n    \n    def _sift_up(self, i):\n        parent = self.parent(i)\n        if i > 0 and self.heap[parent] > self.heap[i]:\n            self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i]\n            self._sift_up(parent)\n    \n    def _sift_down(self, i):\n        min_idx = i\n        left = self.left_child(i)\n        right = self.right_child(i)\n        \n        if left < len(self.heap) and self.heap[left] < self.heap[min_idx]:\n            min_idx = left\n        \n        if right < len(self.heap) and self.heap[right] < self.heap[min_idx]:\n            min_idx = right\n        \n        if i != min_idx:\n            self.heap[i], self.heap[min_idx] = self.heap[min_idx], self.heap[i]\n            self._sift_down(min_idx)\n    \n    def size(self):\n        return len(self.heap)\n\n# Priority Queue using the Min Heap\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = MinHeap()\n    \n    def enqueue(self, val):\n        self.heap.insert(val)\n    \n    def dequeue(self):\n        return self.heap.extract_min()\n    \n    def peek(self):\n        return self.heap.get_min()\n    \n    def is_empty(self):\n        return self.heap.size() == 0\n    \n    def size(self):\n        return self.heap.size()\n\n# Example usage\npq = PriorityQueue()\npq.enqueue(5)\npq.enqueue(2)\npq.enqueue(8)\npq.enqueue(1)\n\nprint(\"Priority Queue size:\", pq.size())\nprint(\"Top element:\", pq.peek())\n\nprint(\"Elements in order of priority:\")\nwhile not pq.is_empty():\n    print(pq.dequeue())\n```"
},
{
"id": "12",
"category": "Hashing",
"question": "How would you implement a hash table from scratch?",
"solution": "A hash table uses a hash function to map keys to values for efficient lookup.\n\n```python\nclass HashNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n\nclass HashTable:\n    def __init__(self, capacity=10):\n        self.capacity = capacity\n        self.size = 0\n        self.buckets = [None] * capacity\n    \n    def _hash(self, key):\n        # Simple hash function for strings\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value += ord(char)\n            return hash_value % self.capacity\n        # For integers and other hashable types\n        return hash(key) % self.capacity\n    \n    def insert(self, key, value):\n        # Find the bucket index\n        index = self._hash(key)\n        \n        # Check if key exists and update value\n        current = self.buckets[index]\n        while current:\n            if current.key == key:\n                current.value = value\n                return\n            current = current.next\n        \n        # Key not found, create new node\n        new_node = HashNode(key, value)\n        new_node.next = self.buckets[index]\n        self.buckets[index] = new_node\n        self.size += 1\n        \n        # Resize if load factor exceeds threshold\n        if self.size >= self.capacity * 0.7:\n            self._resize(self.capacity * 2)\n    \n    def get(self, key):\n        index = self._hash(key)\n        current = self.buckets[index]\n        \n        while current:\n            if current.key == key:\n                return current.value\n            current = current.next\n        \n        # Key not found\n        return None\n    \n    def remove(self, key):\n        index = self._hash(key)\n        current = self.buckets[index]\n        prev = None\n        \n        while current:\n            if current.key == key:\n                # Remove the node\n                if prev:\n                    prev.next = current.next\n                else:\n                    self.buckets[index] = current.next\n                self.size -= 1\n                return current.value\n            prev = current\n            current = current.next\n        \n        # Key not found\n        return None\n    \n    def _resize(self, new_capacity):\n        old_buckets = self.buckets\n        self.capacity = new_capacity\n        self.buckets = [None] * new_capacity\n        self.size = 0\n        \n        # Rehash all existing key-value pairs\n        for bucket in old_buckets:\n            current = bucket\n            while current:\n                self.insert(current.key, current.value)\n                current = current.next\n    \n    def __str__(self):\n        result = \"{}\"\n        for bucket in self.buckets:\n            current = bucket\n            while current:\n                result += f\"{current.key}: {current.value}, \"\n                current = current.next\n        return result[:-2] if len(result) > 2 else result\n\n# Example usage\nht = HashTable()\nht.insert(\"name\", \"John\")\nht.insert(\"age\", 30)\nht.insert(\"city\", \"New York\")\n\nprint(\"Hash Table:\", ht)\nprint(\"Getting 'age':\", ht.get(\"age\"))\n\nprint(\"Removing 'age':\", ht.remove(\"age\"))\nprint(\"Hash Table after removal:\", ht)\n```"
},
{
"id": "13",
"category": "Backtracking",
"question": "Solve the N-Queens problem using backtracking",
"solution": "The N-Queens problem can be solved efficiently using backtracking.\n\n```python\ndef solve_n_queens(n):\n    def create_board(positions):\n        board = []\n        for i in range(n):\n            row = ['.' for _ in range(n)]\n            if i < len(positions):\n                row[positions[i]] = 'Q'\n            board.append(''.join(row))\n        return board\n    \n    def is_safe(row, col, positions):\n        # Check if a queen can be placed at (row, col)\n        for prev_row, prev_col in enumerate(positions):\n            # Check if queens attack each other\n            if prev_col == col or \\\n               prev_row - prev_col == row - col or \\\n               prev_row + prev_col == row + col:\n                return False\n        return True\n    \n    def solve(row, positions):\n        if row == n:\n            # Found a solution\n            result.append(create_board(positions))\n            return\n        \n        for col in range(n):\n            if is_safe(row, col, positions):\n                positions.append(col)\n                solve(row + 1, positions)\n                positions.pop()  # Backtrack\n    \n    result = []\n    solve(0, [])\n    return result\n\n# Example usage\ndef print_solution(board):\n    for row in board:\n        print(row)\n    print()\n\nn = 4\nsolutions = solve_n_queens(n)\nprint(f\"Found {len(solutions)} solutions for {n}-Queens problem:\")\n\nfor i, solution in enumerate(solutions):\n    print(f\"Solution {i+1}:\")\n    print_solution(solution)\n```"
},
{
"id": "14",
"category": "Divide and Conquer",
"question": "Find the maximum and minimum element in an array using divide and conquer",
"solution": "Divide and conquer can efficiently find the maximum and minimum elements.\n\n```python\ndef find_max_min(arr, left, right):\n    # Base case: single element\n    if left == right:\n        return arr[left], arr[left]\n    \n    # Base case: two elements\n    if right - left == 1:\n        return max(arr[left], arr[right]), min(arr[left], arr[right])\n    \n    # Recursive case: divide and conquer\n    mid = (left + right) // 2\n    max1, min1 = find_max_min(arr, left, mid)\n    max2, min2 = find_max_min(arr, mid + 1, right)\n    \n    return max(max1, max2), min(min1, min2)\n\ndef find_max_min_wrapper(arr):\n    if not arr:\n        return None, None\n    return find_max_min(arr, 0, len(arr) - 1)\n\n# Example usage\narr = [3, 5, 1, 8, 9, 2, 6, 7, 4]\nmax_val, min_val = find_max_min_wrapper(arr)\nprint(f\"Maximum value: {max_val}\")\nprint(f\"Minimum value: {min_val}\")\n\n# Compare with built-in functions\nprint(f\"Using built-in functions: max={max(arr)}, min={min(arr)}\")\n```"
},
{
"id": "15",
"category": "String Algorithms",
"question": "Implement a function to find the longest common substring of two strings",
"solution": "The longest common substring problem can be solved using dynamic programming.\n\n```python\ndef longest_common_substring(s1, s2):\n    # Create DP table\n    m, n = len(s1), len(s2)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Variables to store result\n    max_length = 0\n    end_pos = 0\n    \n    # Fill dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n                \n                if dp[i][j] > max_length:\n                    max_length = dp[i][j]\n                    end_pos = i\n    \n    # Extract the substring\n    start_pos = end_pos - max_length\n    result = s1[start_pos:end_pos]\n    \n    return result, max_length\n\n# Example usage\ns1 = \"ABABC\"\ns2 = \"BABCA\"\nsubstring, length = longest_common_substring(s1, s2)\nprint(f\"Longest common substring: '{substring}' with length {length}\")\n```"
},
{
"id": "16",
"category": "String Algorithms",
"question": "Explain and implement the Knuth-Morris-Pratt (KMP) string matching algorithm",
"solution": "KMP is an efficient string searching algorithm that uses a pre-processed pattern.\n\n```python\ndef compute_lps_array(pattern):\n    \"\"\"Compute Longest Prefix Suffix (LPS) array for KMP\"\"\"\n    m = len(pattern)\n    lps = [0] * m  # lps[i] = length of longest proper prefix which is also suffix of pattern[0...i]\n    \n    # Length of the previous longest prefix suffix\n    length = 0\n    i = 1\n    \n    while i < m:\n        if pattern[i] == pattern[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                # This is tricky. Consider the example AAACAAAA and i = 7\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    \n    return lps\n\ndef kmp_search(text, pattern):\n    \"\"\"KMP string matching algorithm\"\"\"\n    n = len(text)\n    m = len(pattern)\n    \n    if m == 0:\n        return [0]  # Empty pattern matches at position 0\n    \n    # Preprocess the pattern\n    lps = compute_lps_array(pattern)\n    \n    matches = []\n    i = 0  # Index for text\n    j = 0  # Index for pattern\n    \n    while i < n:\n        if pattern[j] == text[i]:\n            i += 1\n            j += 1\n        \n        if j == m:  # Found a match\n            matches.append(i - j)\n            j = lps[j - 1]  # Look for the next match\n        elif i < n and pattern[j] != text[i]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    \n    return matches\n\n# Example usage\ntext = \"ABABDABACDABABCABAB\"\npattern = \"ABABCABAB\"\nmatches = kmp_search(text, pattern)\nprint(f\"Pattern found at indices: {matches}\")\n\n# Verify with Python's built-in method\nbuilt_in_matches = [i for i in range(len(text) - len(pattern) + 1) if text[i:i+len(pattern)] == pattern]\nprint(f\"Built-in search results: {built_in_matches}\")\n```"
},
{
"id": "17",
"category": "String Algorithms",
"question": "Implement the Rabin-Karp algorithm for string matching",
"solution": "Rabin-Karp uses hashing to find substring matches efficiently.\n\n```python\ndef rabin_karp(text, pattern):\n    n = len(text)\n    m = len(pattern)\n    \n    if m > n or m == 0:\n        return []\n    \n    # Prime number for hash calculation\n    prime = 101\n    \n    # Calculate hash for pattern and first window of text\n    pattern_hash = 0\n    text_hash = 0\n    \n    # Calculate initial hash values\n    for i in range(m):\n        pattern_hash = (pattern_hash + ord(pattern[i])) % prime\n        text_hash = (text_hash + ord(text[i])) % prime\n    \n    matches = []\n    \n    # Slide pattern over text one by one\n    for i in range(n - m + 1):\n        # Check hash values and then do character by character matching\n        if pattern_hash == text_hash:\n            # Verify character by character\n            match = True\n            for j in range(m):\n                if text[i + j] != pattern[j]:\n                    match = False\n                    break\n            \n            if match:\n                matches.append(i)\n        \n        # Calculate hash for next window\n        if i < n - m:\n            # Remove first character and add next character\n            text_hash = (text_hash - ord(text[i]) + ord(text[i + m])) % prime\n            # Handle negative hash\n            if text_hash < 0:\n                text_hash += prime\n    \n    return matches\n\n# Example usage\ntext = \"ABABDABACDABABCABAB\"\npattern = \"ABABCABAB\"\nmatches = rabin_karp(text, pattern)\nprint(f\"Pattern found at indices: {matches}\")\n```"
},
{
"id": "18",
"category": "Tries",
"question": "Implement a Trie data structure for efficient string operations",
"solution": "A Trie is an efficient data structure for storing and searching strings.\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n    \n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n    \n    def starts_with(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n    \n    def get_words_with_prefix(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return []\n            node = node.children[char]\n        \n        results = []\n        self._collect_words(node, prefix, results)\n        return results\n    \n    def _collect_words(self, node, prefix, results):\n        if node.is_end_of_word:\n            results.append(prefix)\n        \n        for char, child in node.children.items():\n            self._collect_words(child, prefix + char, results)\n\n# Example usage\ntrie = Trie()\nwords = [\"apple\", \"app\", \"application\", \"banana\", \"bat\", \"bath\"]\n\nfor word in words:\n    trie.insert(word)\n\nprint(f\"Search 'apple': {trie.search('apple')}\")\nprint(f\"Search 'app': {trie.search('app')}\")\nprint(f\"Search 'appl': {trie.search('appl')}\")\nprint(f\"Starts with 'app': {trie.starts_with('app')}\")\nprint(f\"Words with prefix 'app': {trie.get_words_with_prefix('app')}\")\nprint(f\"Words with prefix 'ba': {trie.get_words_with_prefix('ba')}\")\n```"
},
{
"id": "19",
"category": "Bit Manipulation",
"question": "Explain common bit manipulation techniques and their applications",
"solution": "Bit manipulation operations are fundamental in many algorithms.\n\n```python\ndef bit_operations_examples():\n    # Basic operations\n    print(\"Bit manipulation operations:\\n\")\n    \n    # 1. Set a bit at position\n    def set_bit(num, position):\n        return num | (1 << position)\n    \n    # 2. Clear a bit at position\n    def clear_bit(num, position):\n        return num & ~(1 << position)\n    \n    # 3. Toggle a bit at position\n    def toggle_bit(num, position):\n        return num ^ (1 << position)\n    \n    # 4. Check if bit is set at position\n    def is_bit_set(num, position):\n        return (num & (1 << position)) != 0\n    \n    # Examples\n    num = 42  # Binary: 101010\n    print(f\"Original number: {num} (binary: {bin(num)[2:].zfill(8)})\")\n    \n    # Setting the 3rd bit (0-indexed)\n    set_result = set_bit(num, 3)\n    print(f\"After setting bit 3: {set_result} (binary: {bin(set_result)[2:].zfill(8)})\")\n    \n    # Clearing the 1st bit\n    clear_result = clear_bit(num, 1)\n    print(f\"After clearing bit 1: {clear_result} (binary: {bin(clear_result)[2:].zfill(8)})\")\n    \n    # Toggling the 5th bit\n    toggle_result = toggle_bit(num, 5)\n    print(f\"After toggling bit 5: {toggle_result} (binary: {bin(toggle_result)[2:].zfill(8)})\")\n    \n    # Checking if bits are set\n    print(f\"Is bit 1 set? {is_bit_set(num, 1)}\")\n    print(f\"Is bit 2 set? {is_bit_set(num, 2)}\")\n    \n    # Common bit manipulation tricks\n    print(\"\\nCommon bit manipulation tricks:\")\n    \n    # 1. Get the lowest set bit\n    def get_lowest_set_bit(num):\n        return num & -num\n    \n    # 2. Count set bits (Brian Kernighan's algorithm)\n    def count_set_bits(num):\n        count = 0\n        while num:\n            num &= num - 1  # Clear the least significant set bit\n            count += 1\n        return count\n    \n    # 3. Check if number is a power of 2\n    def is_power_of_two(num):\n        return num > 0 and (num & (num - 1)) == 0\n    \n    # 4. Find the next power of 2\n    def next_power_of_two(num):\n        if num <= 0:\n            return 1\n        # Decrement by 1, then set all bits after MSB\n        num -= 1\n        num |= num >> 1\n        num |= num >> 2\n        num |= num >> 4\n        num |= num >> 8\n        num |= num >> 16\n        return num + 1\n    \n    # Examples\n    test_num = 42\n    print(f\"For number {test_num}:\")\n    print(f\"Lowest set bit: {get_lowest_set_bit(test_num)} (binary: {bin(get_lowest_set_bit(test_num))[2:].zfill(8)})\")\n    print(f\"Number of set bits: {count_set_bits(test_num)}\")\n    print(f\"Is power of 2? {is_power_of_two(test_num)}\")\n    print(f\"Next power of 2: {next_power_of_two(test_num)}\")\n    \n    # Testing power of 2\n    power2_num = 64\n    print(f\"\\nFor number {power2_num}:\")\n    print(f\"Is power of 2? {is_power_of_two(power2_num)}\")\n\n# Run the examples\nbit_operations_examples()\n```"
},
{
"id": "20",
"category": "Cache Algorithms",
"question": "Implement an LRU (Least Recently Used) Cache",
"solution": "An LRU Cache combines a hash map and doubly linked list for O(1) operations.\n\n```python\nclass LRUCache:\n    class Node:\n        def __init__(self, key=None, value=None):\n            self.key = key\n            self.value = value\n            self.prev = None\n            self.next = None\n    \n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}  # Map key to node\n        \n        # Initialize doubly linked list with dummy head and tail\n        self.head = self.Node()\n        self.tail = self.Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def _add_node(self, node):\n        # Always add new node right after head\n        node.prev = self.head\n        node.next = self.head.next\n        \n        self.head.next.prev = node\n        self.head.next = node\n    \n    def _remove_node(self, node):\n        # Remove node from linked list\n        prev = node.prev\n        new_next = node.next\n        \n        prev.next = new_next\n        new_next.prev = prev\n    \n    def _move_to_head(self, node):\n        # Move node to the head (most recently used)\n        self._remove_node(node)\n        self._add_node(node)\n    \n    def _pop_tail(self):\n        # Remove and return the LRU item from the tail\n        res = self.tail.prev\n        self._remove_node(res)\n        return res\n    \n    def get(self, key):\n        node = self.cache.get(key)\n        if not node:\n            return -1  # Key doesn't exist\n        \n        # Move node to the head (recently used)\n        self._move_to_head(node)\n        \n        return node.value\n    \n    def put(self, key, value):\n        node = self.cache.get(key)\n        \n        if not node:\n            # Create new node\n            new_node = self.Node(key, value)\n            self.cache[key] = new_node\n            self._add_node(new_node)\n            \n            # Check capacity and evict if necessary\n            if len(self.cache) > self.capacity:\n                lru = self._pop_tail()\n                del self.cache[lru.key]\n        else:\n            # Update value and move to head\n            node.value = value\n            self._move_to_head(node)\n    \n    def __str__(self):\n        values = []\n        current = self.head.next\n        while current != self.tail:\n            values.append(f\"{current.key}: {current.value}\")\n            current = current.next\n        return \"{\" + \", \".join(values) + \"}\"\n\n# Example usage\nlru_cache = LRUCache(2)  # Capacity of 2\n\nlru_cache.put(1, 1)  # cache is {1=1}\nprint(\"After put(1, 1):\", lru_cache)\n\nlru_cache.put(2, 2)  # cache is {1=1, 2=2}\nprint(\"After put(2, 2):\", lru_cache)\n\nprint(\"get(1):\", lru_cache.get(1))  # returns 1, cache is now {2=2, 1=1}\nprint(\"After get(1):\", lru_cache)\n\nlru_cache.put(3, 3)  # evicts key 2, cache is {1=1, 3=3}\nprint(\"After put(3, 3):\", lru_cache)\n\nprint(\"get(2):\", lru_cache.get(2))  # returns -1 (not found)\nprint(\"After get(2):\", lru_cache)\n\nlru_cache.put(4, 4)  # evicts key 1, cache is {3=3, 4=4}\nprint(\"After put(4, 4):\", lru_cache)\n\nprint(\"get(1):\", lru_cache.get(1))  # returns -1 (not found)\nprint(\"get(3):\", lru_cache.get(3))  # returns 3\nprint(\"get(4):\", lru_cache.get(4))  # returns 4\n```"
},
{
"id": "21",
"category": "Geometric Algorithms",
"question": "Implement a function to check if two line segments intersect",
"solution": "Line segment intersection can be determined using the orientation method.\n\n```python\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef orientation(p, q, r):\n    \"\"\"Find orientation of triplet (p, q, r).\n    Returns:\n     0 --> Collinear\n     1 --> Clockwise\n    -1 --> Counterclockwise\n    \"\"\"\n    val = (q.y - p.y) * (r.x - q.x) - \\\n          (q.x - p.x) * (r.y - q.y)\n    \n    if val == 0:\n        return 0  # Collinear\n    return 1 if val > 0 else -1  # Clockwise or Counterclockwise\n\ndef on_segment(p, q, r):\n    \"\"\"Check if point q lies on line segment 'pr'\"\"\"\n    return (q.x <= max(p.x, r.x) and q.x >= min(p.x, r.x) and\n            q.y <= max(p.y, r.y) and q.y >= min(p.y, r.y))\n\ndef do_intersect(p1, q1, p2, q2):\n    \"\"\"Check if the line segments p1q1 and p2q2 intersect.\"\"\"\n    # Find the four orientations needed for general and special cases\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n    \n    # General case\n    if o1 != o2 and o3 != o4:\n        return True\n    \n    # Special Cases\n    # p1, q1 and p2 are collinear and p2 lies on segment p1q1\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    \n    # p1, q1 and q2 are collinear and q2 lies on segment p1q1\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    \n    # p2, q2 and p1 are collinear and p1 lies on segment p2q2\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    \n    # p2, q2 and q1 are collinear and q1 lies on segment p2q2\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n    \n    return False\n\n# Example usage\np1 = Point(1, 1)\nq1 = Point(10, 1)\np2 = Point(1, 2)\nq2 = Point(10, 2)\n\nprint(f\"Do line segments intersect? {do_intersect(p1, q1, p2, q2)}\")\n\np3 = Point(10, 0)\nq3 = Point(0, 10)\np4 = Point(0, 0)\nq4 = Point(10, 10)\n\nprint(f\"Do line segments intersect? {do_intersect(p3, q3, p4, q4)}\")\n```"
},
{
"id": "22",
"category": "Geometric Algorithms",
"question": "Implement a function to find the convex hull of a set of points",
"solution": "The convex hull can be found using Graham's scan algorithm.\n\n```python\nimport math\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"({self.x}, {self.y})\"\n\ndef orientation(p, q, r):\n    \"\"\"Find orientation of triplet (p, q, r).\n    Returns:\n     0 --> Collinear\n     1 --> Clockwise\n    -1 --> Counterclockwise\n    \"\"\"\n    val = (q.y - p.y) * (r.x - q.x) - \\\n          (q.x - p.x) * (r.y - q.y)\n    \n    if val == 0:\n        return 0  # Collinear\n    return 1 if val > 0 else -1  # Clockwise or Counterclockwise\n\ndef distance(p1, p2):\n    \"\"\"Calculate Euclidean distance between two points\"\"\"\n    return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)\n\ndef convex_hull(points):\n    \"\"\"Find the convex hull of a set of points using Graham's scan algorithm\"\"\"\n    n = len(points)\n    if n < 3:\n        return points  # Convex hull not possible with less than 3 points\n    \n    # Find the bottommost point\n    bottom_point = min(points, key=lambda p: (p.y, p.x))\n    \n    # Sort points based on polar angle with respect to bottom_point\n    def polar_angle(p):\n        if p.x == bottom_point.x and p.y == bottom_point.y:\n            return -float('inf')  # Bottom point should be first\n        return math.atan2(p.y - bottom_point.y, p.x - bottom_point.x)\n    \n    sorted_points = sorted(points, key=polar_angle)\n    \n    # Initialize hull with first three points\n    hull = [sorted_points[0], sorted_points[1]]\n    \n    # Process remaining points\n    for i in range(2, n):\n        # Keep removing points as long as the last three points make a non-left turn\n        while len(hull) > 1 and orientation(hull[-2], hull[-1], sorted_points[i]) != -1:\n            hull.pop()\n        hull.append(sorted_points[i])\n    \n    return hull\n\n# Example usage\npoints = [Point(0, 0), Point(1, 1), Point(2, 2), Point(3, 0), \n          Point(0, 3), Point(1, 2), Point(2, 1)]\n\nhull = convex_hull(points)\nprint(\"Convex Hull points:\")\nfor point in hull:\n    print(point)\n```"
},
{
"id": "23",
"category": "Matrix Operations",
"question": "Implement matrix multiplication and discuss its time complexity",
"solution": "Matrix multiplication has a time complexity of O(n³) using the standard algorithm.\n\n```python\ndef matrix_multiply(A, B):\n    \"\"\"Multiply two matrices A and B\"\"\"\n    # Check if matrices can be multiplied\n    if len(A[0]) != len(B):\n        raise ValueError(\"Matrix dimensions don't match for multiplication\")\n    \n    # Create result matrix filled with zeros\n    rows_A = len(A)\n    cols_A = len(A[0])\n    cols_B = len(B[0])\n    \n    C = [[0 for _ in range(cols_B)] for _ in range(rows_A)]\n    \n    # Perform multiplication\n    for i in range(rows_A):\n        for j in range(cols_B):\n            for k in range(cols_A):\n                C[i][j] += A[i][k] * B[k][j]\n    \n    return C\n\ndef matrix_multiply_optimized(A, B):\n    \"\"\"Multiply two matrices using NumPy for better performance\"\"\"\n    import numpy as np\n    return np.matmul(np.array(A), np.array(B)).tolist()\n\ndef strassen_matrix_multiply(A, B):\n    \"\"\"Implement Strassen's matrix multiplication algorithm (simplified version)\"\"\"\n    # Only works for square matrices of size 2^n x 2^n\n    n = len(A)\n    \n    # Base case\n    if n == 1:\n        return [[A[0][0] * B[0][0]]]\n    \n    # Divide matrices into quadrants\n    mid = n // 2\n    \n    # Divide A into 4 parts\n    a11 = [row[:mid] for row in A[:mid]]\n    a12 = [row[mid:] for row in A[:mid]]\n    a21 = [row[:mid] for row in A[mid:]]\n    a22 = [row[mid:] for row in A[mid:]]\n    \n    # Divide B into 4 parts\n    b11 = [row[:mid] for row in B[:mid]]\n    b12 = [row[mid:] for row in B[:mid]]\n    b21 = [row[:mid] for row in B[mid:]]\n    b22 = [row[mid:] for row in B[mid:]]\n    \n    # Calculate 7 products recursively (simplified)\n    p1 = strassen_matrix_multiply(a11, matrix_subtract(b12, b22))\n    p2 = strassen_matrix_multiply(matrix_add(a11, a12), b22)\n    p3 = strassen_matrix_multiply(matrix_add(a21, a22), b11)\n    p4 = strassen_matrix_multiply(a22, matrix_subtract(b21, b11))\n    p5 = strassen_matrix_multiply(matrix_add(a11, a22), matrix_add(b11, b22))\n    p6 = strassen_matrix_multiply(matrix_subtract(a12, a22), matrix_add(b21, b22))\n    p7 = strassen_matrix_multiply(matrix_subtract(a11, a21), matrix_add(b11, b12))\n    \n    # Calculate result quadrants\n    c11 = matrix_add(matrix_subtract(matrix_add(p5, p4), p2), p6)\n    c12 = matrix_add(p1, p2)\n    c21 = matrix_add(p3, p4)\n    c22 = matrix_subtract(matrix_subtract(matrix_add(p5, p1), p3), p7)\n    \n    # Combine result quadrants\n    C = []\n    for i in range(mid):\n        C.append(c11[i] + c12[i])\n    for i in range(mid):\n        C.append(c21[i] + c22[i])\n    \n    return C\n\ndef matrix_add(A, B):\n    \"\"\"Add two matrices A and B\"\"\"\n    n = len(A)\n    C = [[0 for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            C[i][j] = A[i][j] + B[i][j]\n    \n    return C\n\ndef matrix_subtract(A, B):\n    \"\"\"Subtract matrix B from matrix A\"\"\"\n    n = len(A)\n    C = [[0 for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            C[i][j] = A[i][j] - B[i][j]\n    \n    return C\n\n# Example usage\nA = [[1, 2, 3],\n     [4, 5, 6]]\n\nB = [[7, 8],\n     [9, 10],\n     [11, 12]]\n\nC = matrix_multiply(A, B)\nprint(\"Matrix multiplication result:\")\nfor row in C:\n    print(row)\n\n# Example with square matrices for Strassen's algorithm\nA = [[1, 2],\n     [3, 4]]\n\nB = [[5, 6],\n     [7, 8]]\n\nC_strassen = strassen_matrix_multiply(A, B)\nprint(\"\\nStrassen's algorithm result:\")\nfor row in C_strassen:\n    print(row)\n\n# Using NumPy for comparison\nimport numpy as np\nC_numpy = np.matmul(np.array(A), np.array(B))\nprint(\"\\nNumPy result:\")\nprint(C_numpy)\n```"
},
{
"id": "24",
"category": "Matrix Operations",
"question": "Implement an algorithm to rotate a matrix by 90 degrees",
"solution": "Matrix rotation can be done in-place for square matrices.\n\n```python\ndef rotate_matrix_90_clockwise(matrix):\n    \"\"\"Rotate an n×n matrix 90 degrees clockwise in-place\"\"\"\n    n = len(matrix)\n    \n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    # Reverse each row\n    for i in range(n):\n        matrix[i].reverse()\n    \n    return matrix\n\ndef rotate_matrix_90_counterclockwise(matrix):\n    \"\"\"Rotate an n×n matrix 90 degrees counterclockwise in-place\"\"\"\n    n = len(matrix)\n    \n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    # Reverse each column\n    for j in range(n):\n        for i in range(n // 2):\n            matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n    \n    return matrix\n\ndef rotate_matrix_90_clockwise_new(matrix):\n    \"\"\"Rotate an n×n matrix 90 degrees clockwise returning a new matrix\"\"\"\n    n = len(matrix)\n    result = [[0 for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            result[j][n-1-i] = matrix[i][j]\n    \n    return result\n\ndef print_matrix(matrix):\n    \"\"\"Print a matrix in a readable format\"\"\"\n    for row in matrix:\n        print(row)\n\n# Example usage\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\nprint(\"Original matrix:\")\nprint_matrix(matrix)\n\n# Create a copy for each rotation to avoid modifying the original\nimport copy\n\nmatrix_clockwise = copy.deepcopy(matrix)\nrotated_clockwise = rotate_matrix_90_clockwise(matrix_clockwise)\nprint(\"\\nRotated 90° clockwise (in-place):\")\nprint_matrix(rotated_clockwise)\n\nmatrix_counterclockwise = copy.deepcopy(matrix)\nrotated_counterclockwise = rotate_matrix_90_counterclockwise(matrix_counterclockwise)\nprint(\"\\nRotated 90° counterclockwise (in-place):\")\nprint_matrix(rotated_counterclockwise)\n\nrotated_new = rotate_matrix_90_clockwise_new(matrix)\nprint(\"\\nRotated 90° clockwise (new matrix):\")\nprint_matrix(rotated_new)\n\n# Using NumPy for comparison\nimport numpy as np\nmatrix_np = np.array(matrix)\nrotated_np "
}
];